<book>
<title>Kha's First Game Jam</title>
<bookinfo>
    <legalnotice><para>Copyright 2015.</para></legalnotice>
    <author><firstname>James</firstname><surname>Hofmann</surname></author>
</bookinfo>
<preface id="khas-first-game-jam">
<docinfo>
</docinfo>
<sect1 id="khas-first-game-jam">
  <title>Kha's First Game Jam</title>
  <para>
    This guide is intended to give you a &quot;real-world&quot;
    introduction to problems and techniques found in game programming,
    as well as the Kha APIs and how to use them in games. A simple but
    finished 2D game is presented with its full source code at each
    stage of development, from the early drawing routines to the final
    polish.
  </para>
  <para>
    Its intended audience is existing programmers who don't necessarily
    know game programming or the Haxe language, and experienced game
    programmers who would like to see a whole project workflow in
    action.
  </para>
</sect1>
</preface>
<chapter id="what is haxe what is kha">
<title>About Kha and Haxe</title>
<sect1 id="what-is-haxe">
  <title>What is Haxe?</title>
  <para>
    Haxe is an ECMAScript-like source code language. It compiles to many
    different source and binary targets, including C++, PHP, Flash SWF,
    JS... It eases portability difficulties by providing a single source
    language, with low-level access to the idioms of each target
    platform.
  </para>
</sect1>
<sect1 id="what-is-kha">
  <title>What is Kha?</title>
  <para>
    Kha is a low-level framework that builds on the Haxe compiler
    technology. Like Haxe itself, it abstracts the details of different
    platforms to ease portability concerns. Kha builds on Haxe to offer
    a framework suitable for real-time multimedia applications,
    particularly games.
  </para>
    <sect2 id="i-dont-understand-what-that-means">
      <title>I don't understand what that means?</title>
      <para>
        Write code in Haxe. The Kha build process produces an appropriate
        build for the target platform.
      </para>
      <para>
        Then work with the toolchain of the target platform to debug it.
      </para>
    </sect2>
    <sect2 id="khas-name">
        <title>Where does Kha come from?</title>
        <para>
        Kha is one of a series of portability frameworks Robert Konrad
        wrote.
        It is directly based on "Kje", a Java framework, and has
        been developed since 2012. The "ha" stands for Haxe, of course.
        </para>
    </sect2>
</sect1>
<sect1 id="what-is-the-benefit">
  <title>What is the benefit?</title>
  <para>
    Haxe is designed for high compatibility. It is a easy language to
    get started with if you are familiar with popular scripting
    languages like Javascript, Lua, Python, or Ruby. It has many
    features that those languages do not have, and a fast, powerful
    compiler that will catch many errors for you and perform
    optimizations that would be out of reach otherwise.
  </para>
  <para>
    Haxe is also excellent at allowing you to defer final technology
    choices until later. The same codebase can compile to many different
    targets, and also many different APIs. If you discover, for example,
    that Kha does not work out, you have many options to migrate the
    code to a different API - either native APIs or another framework.
    You will not have to rewrite the entire codebase in another
    language.
  </para>
  <para>
    Lastly, by working in Haxe you will learn techniques for writing
    reliable, highly portable code - not just in Haxe, but in all the
    environments Haxe targets. The Haxe ecosystem is designed around
    making sure all targets have <emphasis>viable solutions</emphasis>. 
    This means that for any given problem you encounter, there is some way
    to access the native functionality of the target to resolve that problem,
    while still working with Haxe abstractions for the majority of the code.
    You gain the possibility of using the debugging tools of more than one target,
    which improves your chances of quickly resolving a difficult bug.
  </para>
  <para>
    Many Haxe users claim higher overall productivity with Haxe than in
    other environments.
  </para>
</sect1>
<sect1 id="what-weaknesses-does-haxe-have">
  <title>What weaknesses does Haxe have?</title>
  <para>
    Although Haxe is mostly familiar for a former Actionscript or
    Javascript programmer, some aspects may be new and challenging. The
    compiler's type inference engine will catch many of your minor
    mistakes quickly, but typing time is higher. Haxe style encourages
    full use of static types, and many of the tricks based on dynamic
    typing that are used in, for example, Ruby, are poor style in Haxe
    because they do not leverage the type system efficiently. There are
    plenty of new static-typed tricks to learn instead :)
  </para>
  <para>
    You will also encounter more friction within the toolchain because
    it is not exactly designed around the native tools of the target
    environment. Debugging problems buried in the toolchain may require
    domain knowledge that &quot;bridges the gap&quot; from the framework
    into the target. Because crossplatform frameworks have multiple
    implementations of their APIs, behaviors may change slightly across
    targets, leading to &quot;write once debug everywhere&quot;. Good
    frameworks like Kha will also get out of the way and ease the
    process of writing things in a cross-platform way.
  </para>
  <para>
    Haxe expects a garbage-collected environment, and builds itself on a
    relatively high-level runtime. This limits its utility for the most
    demanding games that need low-level control over memory allocation
    behaviors. In the average case, garbage collection problems can be
    overcome by eliminating spurious allocations and reusing more data,
    through, for example, object pooling. Memory allocation only becomes
    a serious concern as your project becomes more likely to allocate
    memory. Simpler scenes and simulations will make garbage collections
    both smaller and less frequent, limiting any potential impact on
    framerates.
  </para>
  <para>
    Now you may still be wondering, "how do I know how demanding my project will be?"
    and the answer is, for pretty much any game or media project on the planet: 
    <emphasis>as much or as little as you want.</emphasis>
    The data sets are fixed. You can always find a way to dial down
    the level of detail presented. So the most legitimate answer is that you only want 
    a lower level solution if you are explicitly aiming to push the boundaries of
    the machine and make it process as much as possible - for anything less than that, 
    modern devices allow you to make tradeoffs, and nobody can tell you
    what that translates to in useful high-level terms like "scene complexity" or 
    "quality of AI". Benchmarks are mostly informative to system bottlenecks, 
    and those bottlenecks may not be relevant to your design after all features are added.
    To quote a friend of mine, working on a little C++ project a few years ago:
  </para>
  <blockquote>
    <para><emphasis>
        I am leaking megabytes every second and not even noticing.
    </emphasis></para>
  </blockquote>
  <para>
    So to make useful benchmarks for yourself, always design towards some maximums, 
    and make sure the framework can handle those maximums with some headroom to spare.
    Design limits build creative spaces - don't think of them as
    settling for less. If you can achieve an effect with less, that's usually better.
    That goes for limits that aren't based in technical constraints, too!
  </para>
</sect1>
<sect1 id="why-is-kha-special">
<title>Why is Kha special?</title>
Kha aims for a new standard of crossplatform games technology, with a graphics and sound API that can successfully span many different environments and accommodate major variations in features exposed.
</sect1>
<sect1 id="kha-versus-openfl-and-unity3d">
  <title>Kha versus OpenFL and Unity3D</title>
  <sect2 id="is-kha-related-to-openfl-or-nme-will-one-give-me-better-performance-will-i-be-locked-in">
    <title>Is Kha related to OpenFL or NME? Will one give me better
    performance? Will I be locked in?</title>
    <para>
      OpenFL is another project that uses the Haxe technology to create
      a cross-platform framework. The goals of the projects are
      different:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          OpenFL is best for programmers who wish to continue to work
          with the Flash APIs, and primarily in 2D. It aims to provide a
          Flash-like experience everywhere, but also provides certain
          low-level features that are not native to Flash.
        </para>
      </listitem>
      <listitem>
        <para>
          NME is a variant on OpenFL that has at various times been the
          same project, sharing similar goals. It presently aims to be a
          purely &quot;native platform&quot; target, supporting more
          low-level access.
        </para>
      </listitem>
      <listitem>
        <para>
          Kha is a purely low-level cross-platform framework, and
          supports 2D and 3D. It provides fewer and simpler APIs, but
          has strong provisions for graphics rendering, including fonts
          and shaders.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The featuresets of each of these frameworks overlap, but all are
      capable of decent to great performance, depending on what you do
      and how you do it. Because they use the same language, you will
      also enjoy a less costly migration if you discover you need to
      switch frameworks.
    </para>
  </sect2>
  <sect2 id="is-kha-better-than-unity3d">
    <title>Is Kha better than Unity3D?</title>
    <para>
      Many core capabilities are already available in Kha, but Unity is
      much more fleshed out and tested as a game engine. The difference
      is in whether you are aiming to implement &quot;engine bits&quot;
      like collision detection and physics, or if you can use an
      off-the-shelf solution effectively. Unity provides the latter, more complete
      solution, and, assuming you're already familiar with it,
      is better for rapid prototyping of typical scenes. Kha is better at
      being the underpinning of a game engine. Game engines such as Khapunk have
      already been ported to work on Kha. UI toolkits like HaxeUI also support Kha
      as a display layer target.
    </para>
    <para>
      If you want to mix Kha and Unity, or Haxe and Unity, that is also
      an option: Kha has a Unity3D export target, and there are several
      bindings to Unity APIs from Haxe, ensuring that your codebase can
      be migrated if necessary.
    </para>
  </sect2>
</sect1>
</chapter>



<chapter id="project setup">
<title>Project Setup</title>
<sect1 id="project-setup">
  <title>Project Setup</title>
  <sect2 id="how-should-i-get-started-with-kha">
    <title>How should I get started with Kha?</title>
    <para>
      There are two ways to work with Kha, the &quot;haxelib&quot; way
      and the &quot;standalone&quot; way. The haxelib way is familiar to
      existing Haxe users. The standalone way allows a project's whole
      environment to be maintained without accidentially losing
      important dependencies, and so it is less dependent on the
      &quot;Haxe ecosystem&quot;.
    </para>
    <para>
      In both cases, your workflow after installation is:
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Run khamake to compile the assets and project metadata for a
          target platform(html5, windows, etc.)
        </para>
      </listitem>
      <listitem>
        <para>
          Test and debug using additional compilers and IDEs appropriate
          to your target(e.g. Visual Studio, Unity editor, browser).
        </para>
      </listitem>
    </orderedlist>
    <para>
      Robert, Kha's maintainer, says:
    </para>
    <blockquote>
      <para>
        <emphasis>The haxelib version is for beginners, standalone is
        for pros. Using haxelib is easier (when you already use Haxe)
        and haxelib Kha isn't copied to the actual projects, so it takes
        up less space. Standalone is highly recommended when starting an
        actual project because you can then version Kha with your
        project.</emphasis>
      </para>
      <para>
        <emphasis>The only actual differences are that haxelib Kha
        includes a copy of node.js. Standalone Kha doesn't but includes
        a slightly modified version of Haxe (usual Haxe calls haxelib
        when Java or C# targets are used to download some stuff, in
        Kha's Haxe that's already included).</emphasis>
      </para>
      <para>
        <emphasis>This arrangement is a little more complex but allows
        you to maintain all of the project code as a cohesive
        whole.</emphasis>
      </para>
    </blockquote>
    <sect3 id="haxelib">
      <title>Haxelib</title>
      <para>
        Install a copy of <ulink url="http://www.haxe.org">Haxe</ulink>
        and run
      </para>
      <programlisting>
haxelib install kha
</programlisting>
      <para>
        at the command line, after Haxe is setup.
      </para>
      <para>
        An &quot;Empty&quot; project exists in the haxelib package. Copy
        this to make your project, or download and unzip the
        <ulink url="https://github.com/KTXSoftware/Empty/archive/master.zip">github
        archived copy</ulink>. Then cd to &quot;Empty&quot;.
      </para>
      <para>
        <emphasis role="strong">To run khamake type:</emphasis>
      </para>
      <programlisting>
haxelib run kha
</programlisting>
      <para>
        The remainder of this guide will alias this line as
        &quot;khamake&quot;. You can add targets and options to it.
      </para>
    </sect3>
    <sect3 id="standalone">
      <title>Standalone</title>
      <para>
        Standalone installation requires
        <ulink url="https://git-scm.com/">git</ulink> and
        <ulink url="https://nodejs.org/">node</ulink>. Use this git
        line:
      </para>
      <programlisting>
git clone --recursive https://github.com/KTXSoftware/Empty.git
</programlisting>
      <para>
        This will download lots of stuff, since it's including all of
        Kha. When it's done, the project root is in Empty:
      </para>
      <programlisting>cd Empty</programlisting>
      <para>
        <emphasis role="strong">To run khamake type:</emphasis>
      </para>
      <programlisting>
node Kha/make
</programlisting>
      <para>
        The remainder of this guide will alias this line as
        &quot;khamake&quot;. You can add targets and options to it.
      </para>
      <para>
        Alternate method, using a script that runs khamake:
      </para>
      <para>
        <emphasis role="strong">From Windows cmd type:</emphasis>
      </para>
      <programlisting>
cd build
build
</programlisting>
      <para>
        <emphasis role="strong">From bash type:</emphasis>
      </para>
      <programlisting>
cd build
./build
</programlisting>
      <para>
        This script brings up a prompt for target and options like this,
        and then runs khamake:
      </para>
      <programlisting>
___________________________________
khamake builder
type q to quit.
___________________________________
Specify target:html5
Specify options:
</programlisting>
    </sect3>
  </sect2>
</sect1>
<sect1 id="build-options">
  <title>Build Options</title>
  <programlisting>
khamake
    -&gt; visual studio solution (uncompiled)
        
khamake --compile
    -&gt; visual studio solution (run compiler after)
        
khamake --compile --visualstudio vs2013
    -&gt; visual studio solution (run visual studio 2013 instead of other versions)
        
khamake flash
    -&gt; flash swf
        
khamake html5
    -&gt; html/js

For more commands:
    khamake --help
</programlisting>
  <para>
    The resulting project or binary will live somewhere in the
    &quot;/build&quot; directory and when run should give you a blank
    screen. For more on builds:
  </para>
  <para>
    <xref linkend="testing-and-publishing-the-project">Testing and Publishing the Project</xref>
  </para>
</sect1>
<sect1 id="converting-a-haxelib-project-to-a-standalone-project">
  <title>Converting a haxelib project to a standalone project</title>
  <para>
    If you have a project using Kha in haxelib form, without git, and
    want to convert, the simplest way is to clone the Empty project and
    copy your project files in on top.
  </para>
  <para>
    If you have an existing git repository without Kha, add Kha as a
    submodule like this:
  </para>
  <programlisting>
git submodule add https://github.com/KTXSoftware/Kha
git submodule update --init --recursive
git commit -m &quot;add Kha&quot; 
</programlisting>
</sect1>
<sect1 id="updating-kha-haxelib">
  <title>Updating Kha (haxelib)</title>
  <programlisting>
haxelib upgrade
</programlisting>
</sect1>
<sect1 id="updating-kha-standalone">
  <title>Updating Kha (standalone)</title>
  <programlisting>
git submodule foreach --recursive git pull origin master
git commit -m &quot;update Kha&quot;
</programlisting>
</sect1>
<sect1 id="dependencies-with-standalone-projects">
  <title>Dependencies with standalone projects</title>
  <para>
    In a standalone project we recommend making a copy of dependencies
    within the project. If you want to update from Haxelib, do so
    manually.
  </para>
</sect1>
<sect1 id="flashdevelop">
  <title>FlashDevelop</title>
  <para>
    FlashDevelop (or FD for short) is one of the most popular IDEs for
    Haxe on the Windows platform. Originally made for Flash and
    Actionscript projects, it was extended to support Haxe many years
    ago. Kha can generate FD project files.
  </para>
  <orderedlist>
    <listitem>
      <para>
        To work with Kha and FD, visit the /build directory to notice a
        project file for your build target. Open this to get full IDE
        integration.
      </para>
    </listitem>
    <listitem>
      <para>
        F5 is your &quot;test build&quot; button. It will run Haxe and
        emit new code. If you want new targets or a complete build
        including assets, run khamake again.
      </para>
    </listitem>
  </orderedlist>
</sect1>
<sect1 id="intellij">
  <title>IntelliJ</title>
  <para>
    IntelliJ contains a well-maintained Haxe plugin, available from its
    internal plugin browser, and Kha generates project files for it.
    Make sure the plugin is installed. Then visit the /build directory
    and open the project file for your build target.
  </para>
  <orderedlist>
    <listitem>
      <para>
        IntelliJ will complain about the Git repository settings, but
        you can safely ignore this or replace the settings with your own
        if you wish to fix the Git integration.
      </para>
    </listitem>
    <listitem>
      <para>
        You must also set up the project's SDK. IntelliJ will pop up the
        &quot;Project Structure&quot; dialog and prompt you to add a
        correct SDK when you first try to build the project. You can add
        it by clicking the &quot;New&quot; button adjacent to
        &quot;Module SDK&quot;. This will point to the appropriate Haxe
        compiler and will depend on whether you are in a Haxelib or
        standalone project:
      </para>
    </listitem>
  </orderedlist>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        For Haxelib, use your preferred installation of Haxe.
      </para>
    </listitem>
    <listitem>
      <para>
        For standalone, use &quot;&lt;project&gt;/Tools/haxe&quot;.
      </para>
    </listitem>
  </itemizedlist>
  <orderedlist>
    <listitem>
      <para>
        Finally, in the &quot;Project Structure&quot; dialog, under the
        &quot;Haxe&quot; tab, make sure that the &quot;Skip
        compilation&quot; checkbox is unchecked.
      </para>
    </listitem>
    <listitem>
      <para>
        Ctrl+F9 is your &quot;test build&quot; button. It will run Haxe
        and emit new code. If you want new targets or a complete build
        including assets, run khamake again.
      </para>
    </listitem>
  </orderedlist>
</sect1>
<sect1 id="getting-around-in-haxe">
  <title>Getting around in Haxe</title>
  <para>
    Here is a quick example to familiarize yourself:
  </para>
  <programlisting language="haxe">
package; // Package namespaces are organized by directory structure, supplemented with compiler options
import Std;
import Type;

class Test { // code must be contained inside classes

    public static function main() { // typical boilerplate for a &quot;global&quot; function

        trace(&quot;hello world&quot;); // debug print
        
        var i = 100; // assign Int
        var f = 3.14; // assign Float
        var s = &quot;50&quot;; // assign String
        
        var si = Std.parseInt(s); // Std contains everyday type conversions
        
        if (i + si == 150) { // ECMA-style optional-brace syntax
           // print &quot;100 + 50 = 150&quot; two ways:
           
           // with concatenation
           trace(Std.string(i) + &quot; + &quot; + s + &quot; = 150&quot;);
           // with string interpolation
           trace('$i + $s = ${i+si}');
        }
        
        var iar = [1,2,3]; // array assignment
        var iar2 = new Array&lt;Int&gt;(); // alternate method
        var iar3 : Array&lt;Int&gt;; // declare without assignment
        
        // assemble [1,2,3] in iar2
        iar2.push(iar[0]); // 0-indexing
        iar2.push(2);
        iar2.push(iar[iar.length-1]);
        
        for (idx in 0...iar.length) { // counting loop
            trace(iar[idx] == iar2[idx]);
        }
        for (n in iar) { // iterator loop
            trace(iar[n - 1] == n);
        }
        { // braces define a new variable scope
            var c = 0; // this will not live outside the braces
            while(c &lt; iar.length) c+=1;
        }
        
        if (iar3 == null) { // null checks aren't &quot;falsy&quot;
            iar3 = iar.concat(iar2); // concat makes a copy
            trace(iar3.length == 6);
        }
        
        // instantiate a class and call some methods
        var q = new Inserter();
        q.insert(0);
        q.insert(&quot;hello world&quot;);
        q.insert(iar);
        trace(q.numberOfInts()==1);

    }

}

/* one file can contain multiple classes; import rules will default-import classes in the same namespace with the same filename. Additional classes will be hidden until the file is explicitly imported.
*/

class Inserter {

    public var a : Array&lt;Dynamic&gt;; // Haxe allows you to access dynamic typing (but it is considered bad style)
    public var count = 0; // default values can also be used

    public function new() { // all instantiated classes require a new()
        a = [];
    }
    
    public function insert(v : Dynamic) {
        a.push(v);
        count += 1;
    }
    
    public function numberOfInts() : Int {
        var result = 0;
        for (n in a) {
            if (Type.typeof(n)==TInt) // runtime type detection
                result += 1;
        }
        return result;
    }

}
</programlisting>
  <para>
    Also visit <ulink url="http://try.haxe.org/">Try Haxe</ulink> for
    some more basic examples.
  </para>
</sect1>
</chapter>



<chapter id="api-main-class">
<title>Kha API 1: Main class, System</title>
<sect1 id="kha-api-1-main-class-system">
  <para>
    The Empty project already has Kha configure some things about the
    display and update timing, so let's review. For laziness and
    simplicity reasons, we're going to stick with the &quot;Empty&quot;
    naming convention throughout this guide, although you may want to
    pick a cuter name for your project's title and main class.
  </para>
</sect1>
<sect1 id="main.hx">
<title>Main.hx</title>
<programlisting language="haxe">
package;

import kha.Scheduler;
import kha.System;

class Main {
    public static function main() {
        System.init(&quot;Empty&quot;, 640, 480, initialized);
    }
    
    private static function initialized(): Void {
        var game = new Empty();
        System.notifyOnRender(game.render);
        Scheduler.addTimeTask(game.update, 0, 1 / 60);
    }
}
</programlisting>
</sect1>
<sect1 id="empty.hx">
<title>Empty.hx</title>
<programlisting language="haxe">
package;
import kha.Framebuffer;

class Empty {
    public function new() {
        
    }
    
    public function render(framebuffer: Framebuffer): Void {
        
    }
    
    public function update(): Void {
            
    }
}
</programlisting>
<para>
  Running this should still give you a blank screen. We have three
  Kha classes to look at:
</para>
</sect1>
<sect1 id="system">
<title>System</title>
<para>
  This class is the &quot;global state&quot; of your Kha app: It
  holds the render callback, it says how big the screen is and how
  fast it refreshes, etc. We use it here to initialize the screen,
  and then to set up the rendering callback. System also contains:
</para>
<itemizedlist spacing="compact">
  <listitem>
    <para>
      callbacks for various OS/windowing-level events, like being
      minimized or shutdown
    </para>
  </listitem>
  <listitem>
    <para>
      a global &quot;time&quot; value (since startup, measured in
      seconds)
    </para>
  </listitem>
  <listitem>
    <para>
      vsync control
    </para>
  </listitem>
  <listitem>
    <para>
      systemID - what target you are on, e.g. &quot;HTML5&quot;.
    </para>
  </listitem>
</itemizedlist>
</sect1>
<sect1 id="scheduler">
<title>Scheduler</title>
<para>
  This class governs all the interesting timing information in Kha.
  We'll discuss it in depth later. For now, just know that it lets
  you set up recurring tasks like updates to your gameplay,
  independently of the render callback. Although System has a
  &quot;time&quot;, Scheduler has a &quot;framerate-corrected&quot;
  time, so consider using it first if the time is used for gameplay.
</para>
</sect1>
<sect1 id="framebuffer">
<title>Framebuffer</title>
<para>
  This is a class that represents the display we're drawing to from
  the rendering callback. This will get more attention shortly, as
  our next API chapter is about simple drawing.
</para>
</sect1>
</chapter>





<chapter id="testing-and-publishing-the-project">
<title>Testing and Publishing the Project</title>
<sect1 id="testing-the-project">
  <title>Testing the Project</title>
  <para>
    The preferred targets for Kha development are Flash and HTML5.
    Debugging functionality and test iteration times are best on these
    targets. For these targets you may use either your web browser or
    the standalone Flash Projector.
  </para>
  <para>
    For a Windows build the most straightforward option is Visual
    Studio. khabuild will try to autodetect the version you are running
    and generate a VS solution file for you. Then open the solution in
    the IDE, select Debug or Release and do debugging and profiling from
    within VS.
  </para>
</sect1>
<sect1 id="publishing-the-project">
  <title>Publishing the Project</title>
  <para>
    You are ready to show your game to somebody, but you need to get it
    running on their device. This section will depend on your target,
    but Kha has kept the process simple.
  </para>
  <para>
    Robert summarizes:
  </para>
  <blockquote>
    <para>
      <emphasis>For some targets (Windows, Linux,...) you put the
      executable in the windows/linux/... directory, for other targets
      (Android, iOS, OSX,...) the IDE does everything for
      you.</emphasis>
    </para>
  </blockquote>
  <blockquote>
    <para>
      <emphasis>No target has any additional dependencies.</emphasis>
    </para>
  </blockquote>
  <sect2 id="flash">
    <title>Flash</title>
    <para>
      The result is stored in &quot;build/flash&quot; as
      &quot;kha.swf&quot;. Choose your distribution type:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis>Multi-file distribution</emphasis>: This is the
          default build mode. The entire folder, including
          &quot;Assets&quot;, must be uploaded as Kha will load these
          assets at runtime.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Single-file distribution</emphasis>: Use the option
          <emphasis>--addallassets</emphasis> in khabuild.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      After deciding on multi-file or single file:
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Upload either kha.swf or the whole directory to your hosting.
        </para>
      </listitem>
      <listitem>
        <para>
          You must provide your own web page for Flash embedding.
        </para>
      </listitem>
    </orderedlist>
  </sect2>
  <sect2 id="html5">
    <title>HTML5</title>
    <para>
      The result is stored in &quot;build/html5&quot;.
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Upload the directory to a web host and point your users at the
          appropriate URL.
        </para>
      </listitem>
      <listitem>
        <para>
          The build is complete.
        </para>
      </listitem>
    </orderedlist>
  </sect2>
  <sect2 id="desktop">
    <title>Desktop</title>
    <para>
      The result is stored in the appropriate platform target, e.g.
      &quot;build/windows&quot; for example.
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Copy the executable from &quot;windows-build/Release&quot; to
          &quot;build/windows&quot;.
        </para>
      </listitem>
      <listitem>
        <para>
          Package &quot;build/windows&quot; as suits you and send the
          result to your users.
        </para>
      </listitem>
      <listitem>
        <para>
          The build is complete.
        </para>
      </listitem>
    </orderedlist>
  </sect2>
  <sect2 id="build details">
    <title>Build Details</title>
    <para>
      The generated FlashDevelop project or hxml file contains the flag "kha"
      which can be used in an #if block to detect whether the project was built with Kha.
    </para>
  </sect2>
</sect1>
</chapter>




<chapter id="kha-api-2-display">
<title>Kha API 2: Display</title>
<sect1 id="kha-api-2-display">
  <para>
    Now we will render a very simple &quot;strobe the screen with
    different colors&quot;. <emphasis role="strong">Caution: this may be
    seizure-inducing.</emphasis> (lower the display size if you're
    worried)
  </para>
</sect1>
<sect1 id="empty.hx-2">
<title>Empty.hx</title>
<programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;

class Empty {
    public function new() {
        
    }
    
    public function render(framebuffer: Framebuffer): Void {
        var nextcolor = [Color.White, Color.Red, Color.Blue, Color.Green, Color.Black][Std.int(Math.random() * 5)];
        var g = framebuffer.g1;
        g.begin();
        for (y in 0...framebuffer.height) {
        for (x in 0...framebuffer.width) {
        g.setPixel(x,y,nextcolor);
        }
        }
        g.end();
    }
    
    public function update(): Void {
        
    }
}
</programlisting>
</sect1>
<sect1 id="what-is-backbuffer.g1">
<title>What is &quot;backbuffer.g1&quot;?</title>
<para>
  Kha contains different numbered &quot;levels&quot; of its graphics
  API. Graphics1 is the simplest possible system: it can plot pixels
  only.
</para>
<para>
  Here is a replacement of that block using Graphics2:
</para>
<programlisting language="haxe">
var g = framebuffer.g2;
g.begin();
g.clear(nextcolor);
g.end();
</programlisting>
<para>
  Graphics2 adds more &quot;standard&quot; functionality, including
  clearing the screen, drawing shapes and blitting images. It's for
  general-case 2D applications, and its routines can be counted on
  to be faster than plotting individual pixels. We'll expand on
  Graphics2 in later chapters.
</para>
<para>
  There is also a Graphics4, which exposes the full shading
  pipeline. In theory Graphics3 represents fixed-function GPU
  pipelines, but it does not exist at this time. We will not venture
  into Graphics4 in this guide, and focus instead on fleshing out a
  game in Graphics2.
</para>
</sect1>
<sect1 id="why-is-there-a-begin-and-end">
<title>Why is there a begin() and end()?</title>
<para>
  Kha batches the graphics operations internally and processes the
  actual drawing commands when it reaches end(). This lets you code
  your own rendering logic more freely, while letting Kha optimize
  the commands to whatever works best in the target environment.
</para>
</sect1>
</chapter>




<chapter id ="api-graphics2">
<title>API: Graphics2, Scheduler, and Moving Rectangles</title>
<sect1>
<para>
  We will make a clone of the 70's Atari game &quot;Canyon Bomber&quot;.
  In this game, a plane flies over a canyon in side view and drops
  bombs, trying to clear away all the rocks on the board without
  missing. It's one of the earliest &quot;one-button games&quot; and
  presents a well-rounded exercise for Kha's toolset.
</para>
<para>
  In this passage we'll work on moving a rectangle across the screen
  over time, introducing timing and simple animation. The rectangle will
  later become the &quot;bomber plane&quot; in our game.
</para>
</sect1>
<sect1 id="timing-in-kha">
  <title>Timing in Kha</title>
  <para>
    Kha contains a sophisticated timing and scheduling system, but also
    lets you dig into raw timing data.
  </para>
  <programlisting>
Scheduler.addTimeTask(game.simulate, 0, 1 / 60);
</programlisting>
  <para>
    This uses the Scheduler API to call game.simulate 60 times a
    second(every ~16.6 ms), indefinitely.
  </para>
  <sect2 id="period-vs.-duration">
    <title>Period vs. Duration</title>
    <para>
      Period is the total length of a scheduled task. Duration is the
      frequency at which the task is repeated.
    </para>
    <para>
      For example, if you wish to call an event 30 times a second, but
      for only 2 seconds, you would add a task with a duration of 1/30
      and a period of 2.
    </para>
  </sect2>
  <sect2 id="realtime-and-time">
    <title>realTime() and time()</title>
    <para>
      To get the current time since start, use:
    </para>
    <programlisting>
Scheduler.time();
</programlisting>
    <para>
      and
    </para>
    <programlisting>
Scheduler.realTime();
</programlisting>
    <para>
      Scheduler will automatically apply smoothing, limiting, and
      atomization to timing data so that the average-case experience is
      as jitter and pause-free as possible.
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Scheduler.time() is the time that has passed after these
          adjustments.
        </para>
      </listitem>
      <listitem>
        <para>
          Scheduler.realTime() is the system global time, or &quot;wall
          clock&quot; time. Use this one for performance data, or if you
          want to do your own timing from scratch.
        </para>
      </listitem>
    </itemizedlist>
  </sect2>
  <sect2 id="why-atomic-timing-is-useful">
    <title>Why atomic timing is useful</title>
    <para>
      It is tempting to plug in a delta time into your physics
      equations, tweens, etc. and allow the time to float freely.
      Sometimes this is even a correct approach.
    </para>
    <para>
      However, there are two reasons not to do this. One is that it
      makes physics simulations inconsistent - often wildly so. Jump
      heights will be unpredictable, people will go flying at strange
      velocities, etc. The other is that it hurts reproducability
      otherwise, for example if you are recording a demo for playback.
    </para>
    <para>
      Therefore, the most flexible approach is to chop up delta times
      into regular &quot;atoms&quot; of time, and play through them one
      at a time. This is what Kha does inside its Scheduler API. It is
      even designed to support complex use-cases where timers get called
      in a certain order, or are paused or cancelled while active.
    </para>
  </sect2>
</sect1>
<sect1 id="drawing-rectangles">
  <title>Drawing rectangles</title>
  <para>
    We use Graphics2.fillRect() to draw some rectangles. In doing so, we
    also make use of the &quot;color&quot; attribute on Graphics2. We
    already used some color to do our full-screen strobe, but here we
    can see more clearly what is going on.
  </para>
  <para>
    Graphics2 uses a &quot;finite state&quot; model of rendering, where
    we describe a configuration for drawing, and then issue a command
    that updates the state of the framebuffer we are drawing to. So when
    we change color, that changes the color of the drawing commands we
    issue after that change.
  </para>
</sect1>
<sect1 id="scaling">
  <title>Scaling</title>
  <para>
    Oh, how inconvenient! We aren't always going to get the resolution
    we request returned in System.pixelWidth and System.pixelHeight.
    After all, the system can't always give you what you ask for.
  </para>
  <para>
    That also means that if we want to force a certain pixel resolution
    - and this is the type of game where that happens - we're going to
    have to think about scaling.
  </para>
  <para>
    There are two ways we can approach this.
  </para>
  <orderedlist spacing="compact">
    <listitem>
      <para>
        The more &quot;pixel-perfect&quot; way would be to have a
        &quot;<emphasis>back buffer</emphasis>&quot;. Instance an Image
        at our ideal resolution, draw the gameplay on that, then draw
        that, scaled, to the display buffer. That guarantees that
        everything stays on the same pixel grid, no matter what we do.
      </para>
    </listitem>
    <listitem>
      <para>
        But we'll go the other route of adding a <emphasis>scaling
        transform</emphasis> using a FastMatrix3 before our drawing
        calls. This will give us the correct proportions, and it avoids
        an additional trip through the GPU, so it may be somewhat
        faster, but it means that objects may look &quot;wrong&quot; if
        they are scaled, rotated, or placed on subpixel coordinates.
      </para>
    </listitem>
  </orderedlist>
  <para>
    It's very easy to swap between these two methods if you prefer one
    or the other. Variations like only scaling to integer factors of the
    original, cropping the image, etc. are also possible.
  </para>
</sect1>
<sect1 id="the-planes-data-structure-and-algorithms">
  <title>The plane's data structure and algorithms</title>
  <para>
    I decided to make the plane a Haxe Typedef with an x and y position,
    x and y velocity, and a width and height. Although we don't have to
    define a width and height as a <emphasis>variable</emphasis> on the
    plane - it's never going to change during gameplay - it's convenient
    for us, so I splurged.
  </para>
  <para>
    The screen space and the physics space in Canyon Bomber are 1:1, and
    the camera is locked in one position, so no coordinate conversions
    have to take place during rendering - I just enter the position and
    size directly. If I wanted to scroll the screen or zoom in and out,
    this part would become more complex.
  </para>
  <para>
    Then I wrote a routine to move it across the screen each update, and
    make it wrap around as it runs off the edge. This routine will get
    more complex later(and so will the plane's data).
  </para>
  <sect2 id="empty.hx-3">
    <title>Empty.hx</title>
    <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse,onUpMouse, null, null);
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public var fire = false;
    var plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
    
    public function onDown(k : Key, s : String) {
        trace(s + &quot; down&quot;);
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        trace(s+&quot; up&quot;);
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        trace('$button down');
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        trace('$button up');
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        // color settings
        var col_bg = Color.Black;
        if (fire) 
            col_bg = Color.Red;
        var col_plane = Color.White;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.clear(col_bg);
            g.pushTransformation(transform);
            g.color = col_plane;
            g.fillRect(plane.x, plane.y, plane.w, plane.h);
            g.popTransformation();
            g.end();
        }
    }
    
    public function update(): Void {
        { // advance plane movement
            plane.x += plane.vx;
            plane.y += plane.vy;
            // wrap around
            if (plane.x &gt; WIDTH)
                plane.x = -plane.w + 1;
            else if (plane.x &lt; -plane.w)
                plane.x = WIDTH + 1;
        }
    }
}
</programlisting>
  </sect2>
</sect1>
</chapter>




<chapter id="bombs-away">
<title>Bombs Away!</title>
<para>
  Here we add the interaction where the player can drop a bomb by
  pressing a button, and get rid of the input debug stuff now that we
  have a &quot;real&quot; input response.
</para>
<para>
  I am running all the input through the update loop as a way to finely control the
  process of synchronizing the game logic. If we had more substantial state changes on the
  keypress events, it would be harder to follow the flow of the logic, and we might make
  a mistake like trying to manipulate a game object when it's not available. The result is the
  "<emphasis>straight-line</emphasis>" style of coding: 
  Instead of organizing code to maximize potential for indirection,
  we deliberately couple it in a top-to-bottom, heavily inlined fashion, and use 
  simple organization and commenting to understand it.
</para>
<para>
  Because our game design encompasses a final product specification, 
  writing a large straight-line main loop is our most cost-efficient option 
  for maintenance: many features are minor variations on other features, but need new programming,
  not new parameters. Parameterization will only increase the ways in which a code path can fail.
  But don't take my word for it &#x2014; 
  <ulink url="http://number-none.com/blow/john_carmack_on_inlined_code.html">John Carmack also agrees:</ulink>
</para>
<blockquote>
  <para><emphasis>
  The real enemy addressed by inlining is unexpected dependency and mutation of state, which functional programming solves more directly and completely. However, if you are going to make a lot of state changes, having them all happen inline does have advantages; you should be made constantly aware of the full horror of what you are doing. When it gets to be too much to take, figure out how to factor blocks out into pure functions (and don't let them slide back into impurity!).
  </emphasis></para>
</blockquote>
<sect1 id="empty.hx-4">
  <title>Empty.hx</title>
  <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse,onUpMouse, null, null);
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public var fire = false;
    var plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
    var bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render plane
                g.color = col_plane;
                g.fillRect(plane.x, plane.y, plane.w, plane.h);
            }
            if (bomb.alive) { // render bomb
                g.color = col_bomb;
                g.fillRect(bomb.x, bomb.y, bomb.w, bomb.h);
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function update(): Void {
        { // if we tapped the button spawn the bomb, if possible
            if (fire &amp;&amp; !bomb.alive)  {
                bomb.alive = true;
                bomb.x = plane.x;
                bomb.y = plane.y;
                bomb.vx = plane.vx;
                bomb.vy = 0.;
            }
        }
        { // advance plane movement
            plane.x += plane.vx;
            plane.y += plane.vy;
            // wrap around
            if (plane.x &gt; WIDTH)
                plane.x = -plane.w + 1;
            else if (plane.x &lt; -plane.w)
                plane.x = WIDTH + 1;
        }
        { // advance bomb movement
            if (bomb.alive) {
                bomb.vy += 0.2; // gravity
                bomb.x += bomb.vx;
                bomb.y += bomb.vy;
                if (bomb.y &gt; HEIGHT)
                    bomb.alive = false;
            }
        }
    }
}
</programlisting>
</sect1>
</chapter>



<chapter id="drawing-a-canyon">
<title>Drawing a Canyon</title>
<sect1>
<para>
  Here we add some simple tilemap rendering to present a canyon filled
  with rocks. I compile the generic tilemap manipulation stuff into a
  new file and class named Tilemap.hx for convenience. Most of the
  interesting parts will always remain custom to the game, and I put
  those in Empty.
</para>
<para>
  We also add a level start, and some constants to specify the size of
  the level, and some procedural terrain. The bomb doesn't interact with
  the terrain yet, but we'll get there soon!
</para>
<para>
  You may notice that I use a one-dimensional array to describe the
  tiles. This is a convention I adopted some years ago because it turned
  out to be simpler for any task that involved the whole map: I could
  iterate over one array, instead of an array of arrays.
</para>
<para>
  It is also straightforward to convert between a single &quot;tile
  index&quot; integer and an (x, y) pair.
</para>
<para>
  To go from the pair to the index:
</para>
<programlisting language="haxe">
    y * MAP_W + x
</programlisting>
<para>
  To extract the x position:
</para>
<programlisting language="haxe">
    idx % MAP_W
</programlisting>
<para>
  To extract the y position:
</para>
<programlisting language="haxe">
    Std.int(idx / MAP_W)
</programlisting>
<para>
  The most challenging aspect of tilemaps is always with their
  boundaries. Either fallbacks to accommodate edges and out-of-bounds
  always have to be included, or the map has to have some kind of
  built-in padding in its data so that the out-of-bounds case is
  functionally impossible.
</para>
<para>
  The canyon is generated with a procedural technique, converting a
  sequence of heights to a 2D tilemap. To give it the feeling of having
  a &quot;dip&quot; in the middle, I took samples of one half of a sine
  wave cycle. Then I added noise to each sample. Finally, I added a
  smoothing process so that the gaps were not too narrow, making an
  impossible configuration less likely. (A &quot;real&quot; game might
  strive to find a more rigorous way of doing this.)
</para>
</sect1>
<sect1 id="tilemap.hx">
  <title>Tilemap.hx</title>
  <programlisting language="haxe">
package;

class Tilemap&lt;T&gt; {
    
    /* width */         public var w : Int;
    /* height */        public var h : Int;
    /* tile width */    public var tw : Int;
    /* tile height */   public var th : Int;
    public var d : Array&lt;T&gt;;
    
    public function new(w, h, tw, th, v) {
        this.w = w;
        this.h = h;
        this.tw = tw;
        this.th = th;
        this.d = [for (i in 0...w * h) v];
    }
    
    public inline function x(idx : Int) : Int {
        return idx % w;
    }
    
    public inline function y(idx : Int) : Int {
        return Std.int(idx / w);
    }
    
    public inline function i(x : Int, y : Int) : Int {
        if (x &lt; 0) return -1;
        else if (x &gt;= w) return -1;
        else if (y &lt; 0) return -1;
        else if (y &gt;= h) return -1;
        else return y * w + x;
    }

    // tile -&gt; pixel
    public inline function x2p(x : Float) : Float {
        return x * tw;
    }
    
    public inline function y2p(y : Float) : Float {
        return y * th;
    }
    
    // pixel -&gt; tile
    public inline function p2x(p : Float) : Float {
        return p / tw;
    }
    
    public inline function p2y(p : Float) : Float {
        return p / th;
    }
    
    public inline function p2i(x : Float, y : Float) : Int {
        var tx = Std.int(x / tw);
        var ty = Std.int(y / th);
        return i(tx, ty);
    }
    
}
</programlisting>
</sect1>
<sect1 id="empty.hx-5">
  <title>Empty.hx</title>
  <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;

enum MapTile {
    MTNone;
    MTWall;
    MTRock;
}

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        startLevel();
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    
    public var fire = false;
    var plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
    var bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
    var map : Tilemap&lt;MapTile&gt;;
    
    public function startLevel() {
        plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
        bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = MTRock;
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = Color.Orange;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                        case MTRock:
                            g.color = col_rock;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            { // render plane
                g.color = col_plane;
                g.fillRect(plane.x, plane.y, plane.w, plane.h);
            }
            if (bomb.alive) { // render bomb
                g.color = col_bomb;
                g.fillRect(bomb.x, bomb.y, bomb.w, bomb.h);
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function update(): Void {
        { // if we tapped the button spawn the bomb, if possible
            if (fire &amp;&amp; !bomb.alive)  {
                bomb.alive = true;
                bomb.x = plane.x;
                bomb.y = plane.y;
                bomb.vx = plane.vx;
                bomb.vy = 0.;
            }
        }
        { // advance plane movement
            plane.x += plane.vx;
            plane.y += plane.vy;
            // wrap around
            if (plane.x &gt; WIDTH)
                plane.x = -plane.w + 1;
            else if (plane.x &lt; -plane.w)
                plane.x = WIDTH + 1;
        }
        { // advance bomb movement
            if (bomb.alive) {
                bomb.vy += 0.2; // gravity
                bomb.x += bomb.vx;
                bomb.y += bomb.vy;
                if (bomb.y &gt; HEIGHT)
                    bomb.alive = false;
            }
        }
    }
}
</programlisting>
</sect1>

</chapter>






<chapter id="bomb-canyon-collision">
<title>Bomb-Canyon Collision</title>
<para>
  Most action games use a collision simulation for the basic
  &quot;feel&quot; of the game - or to put it another way,
  &quot;collision is gameplay&quot;. This also means that collision is
  customized to each game.
</para>
<para>
  For Canyon Bomber, we have a simple case: we want the bombs to clear
  away rocks until they touch a wall or go offscreen.
</para>
<para>
  To do this we sample each corner of the bomb each frame and translate
  that into a tile coordinate. Then we modify the tile if it's a rock,
  and tell the bomb whether or not it has died. As we proceed through
  the rest of the guide, we'll refine this collision behavior some more
  so that the bomb &quot;feels&quot; correct.
</para>
<para>
  One of the common mathematics challenges that appears during game
  coding is conversion between coordinate systems. Any time you have a
  tile grid, you will encounter some reason to convert between the
  screen coordinates and the grid coordinates. Maybe you are picking a
  tile with mouse or touchscreen input, or you want to find the
  boundaries of a rectangle on the tile grid, or you are trying to
  collide an actor against terrain described through the tilemap(the
  case we have with the bomb).
</para>
<para>
  I already built the conversions we need into Tilemap.hx, fortunately,
  so we will be using those. The most important part, since we're
  working on a one-dimensional array, is that the i() and p2i() methods
  automatically detect invalid coordinates and return a correspondingly
  invalid tile index.
</para>
<sect1 id="empty.hx-6">
  <title>Empty.hx</title>
  <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;

enum MapTile {
    MTNone;
    MTWall;
    MTRock;
}

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        startLevel();
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    
    public var fire = false;
    var plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
    var bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
    var map : Tilemap&lt;MapTile&gt;;
    
    public function startLevel() {
        plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
        bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = MTRock;
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = Color.Orange;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                        case MTRock:
                            g.color = col_rock;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            { // render plane
                g.color = col_plane;
                g.fillRect(plane.x, plane.y, plane.w, plane.h);
            }
            if (bomb.alive) { // render bomb
                g.color = col_bomb;
                g.fillRect(bomb.x, bomb.y, bomb.w, bomb.h);
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function update(): Void {
        { // if we tapped the button spawn the bomb, if possible
            if (fire &amp;&amp; !bomb.alive)  {
                bomb.alive = true;
                bomb.x = plane.x;
                bomb.y = plane.y;
                bomb.vx = plane.vx;
                bomb.vy = 0.;
            }
        }
        { // advance plane movement
            plane.x += plane.vx;
            plane.y += plane.vy;
            // wrap around
            if (plane.x &gt; WIDTH)
                plane.x = -plane.w + 1;
            else if (plane.x &lt; -plane.w)
                plane.x = WIDTH + 1;
        }
        { // advance bomb movement
            if (bomb.alive) {
                bomb.vy += 0.2; // gravity
                bomb.x += bomb.vx;
                bomb.y += bomb.vy;
                var top = bomb.y;
                var left = bomb.x;
                var right = bomb.x + bomb.w;
                var bottom = bomb.y + bomb.h;
                var i0 = map.p2i(left, top);
                var i1 = map.p2i(right, top);
                var i2 = map.p2i(left, bottom);
                var i3 = map.p2i(right, bottom);
                bomb.alive = bomb.alive &amp;&amp; bombCollision(i0)
                                        &amp;&amp; bombCollision(i1)
                                        &amp;&amp; bombCollision(i2)
                                        &amp;&amp; bombCollision(i3);
                if (bomb.y &gt; HEIGHT) 
                    bomb.alive = false;
            }
        }
    }
    
    public function bombCollision(idx : Int) {
        if (idx &lt; 0 || idx &gt; map.d.length) return false;
        else switch(map.d[idx]) {
            case MTNone: return true;
            case MTWall: return false;
            case MTRock: map.d[idx] = MTNone; return true;
        }
    }
    
}
</programlisting>
</sect1>

</chapter>



<chapter id="rock-fall-behavior">
<title>Rock Fall Behavior</title>
<para>
  The other part of Canyon Bomber's collision is for the rocks to fall
  down after the bomb clears underlying areas.
</para>
<para>
  To do this we scan upwards from the bottom of the tile grid. We don't
  have any cascading behavior where the rocks fall to the sides (e.g.
  <emphasis>Boulder Dash</emphasis>), they just fall and stack up in a
  vertical column. So all we have to do is trigger it on the update()
  and give it a delay timer so that the fall rate is believable. (I
  could use Scheduler for this, but prefer having a clear flow through
  the simulation.)
</para>
<para>
  I added some speed to the plane so that we can see the effect more
  clearly.
</para>
<sect1 id="empty.hx-7">
  <title>Empty.hx</title>
  <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;

enum MapTile {
    MTNone;
    MTWall;
    MTRock;
}

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        startLevel();
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    public static inline var ROCKFALL_TIMER = 4;
    
    public var fire = false;
    var plane = { x:0., y:0., w:8., h:8., vx:2., vy:0. };
    var bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
    var map : Tilemap&lt;MapTile&gt;;
    var rockfall_time : Int;
    
    public function startLevel() {
        rockfall_time = 0;
        plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
        bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = MTRock;
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = Color.Orange;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                        case MTRock:
                            g.color = col_rock;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            { // render plane
                g.color = col_plane;
                g.fillRect(plane.x, plane.y, plane.w, plane.h);
            }
            if (bomb.alive) { // render bomb
                g.color = col_bomb;
                g.fillRect(bomb.x, bomb.y, bomb.w, bomb.h);
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function update(): Void {
        { // if we tapped the button spawn the bomb, if possible
            if (fire &amp;&amp; !bomb.alive)  {
                bomb.alive = true;
                bomb.x = plane.x;
                bomb.y = plane.y;
                bomb.vx = plane.vx;
                bomb.vy = 0.;
            }
        }
        { // advance plane movement
            plane.x += plane.vx;
            plane.y += plane.vy;
            // wrap around
            if (plane.x &gt; WIDTH)
                plane.x = -plane.w + 1;
            else if (plane.x &lt; -plane.w)
                plane.x = WIDTH + 1;
        }
        { // advance bomb movement
            if (bomb.alive) {
                bomb.vy += 0.2; // gravity
                bomb.x += bomb.vx;
                bomb.y += bomb.vy;
                var top = bomb.y;
                var left = bomb.x;
                var right = bomb.x + bomb.w;
                var bottom = bomb.y + bomb.h;
                var i0 = map.p2i(left, top);
                var i1 = map.p2i(right, top);
                var i2 = map.p2i(left, bottom);
                var i3 = map.p2i(right, bottom);
                bomb.alive = bomb.alive &amp;&amp; bombCollision(i0)
                                        &amp;&amp; bombCollision(i1)
                                        &amp;&amp; bombCollision(i2)
                                        &amp;&amp; bombCollision(i3);
                if (bomb.y &gt; HEIGHT) 
                    bomb.alive = false;
            }
        }
        if (rockfall_time &lt; 1) { // advance the rock fall
            rockfall_time = ROCKFALL_TIMER;
            for (y in 1...MAP_H) {
                var iy0 = (MAP_H - 1) - y; // rock to fall
                var iy1 = iy0 + 1; // tile underneath
                for (x in 0...MAP_W) {
                    var idx0 = map.i(x, iy0);
                    var idx1 = map.i(x, iy1);
                    if (map.d[idx0] == MTRock &amp;&amp; map.d[idx1] == MTNone) {
                        map.d[idx0] = MTNone;
                        map.d[idx1] = MTRock;
                    }
                }
            }
        } else {
            rockfall_time--;
        }
    }
    
    public function bombCollision(idx : Int) {
        if (idx &lt; 0 || idx &gt; map.d.length) return false;
        else switch(map.d[idx]) {
            case MTNone: return true;
            case MTWall: return false;
            case MTRock: map.d[idx] = MTNone; return true;
        }
    }
    
}
</programlisting>
</sect1>
</chapter>

<chapter id="api-text-khafile">
<title>API 5: Text and khafile.js</title>
<sect1>
<para>
  Let's render some text so that we can start displaying score and
  lives.
</para>
<para>
  Now, if we wanted to do bitmap text like what was in the original
  game, we could start using Graphic2's sprite functionality to do so.
  But we are still in a prototyping mode and it'll be simpler to explore
  the Font API.
</para>
<para>
  First of all, we need to include a font asset in the project. Kha
  fonts are standard TTF files. The framework does all the behind-the-scenes
  work of rendering the text, and provides basic size and positioning information.
</para>
<para>
  Recall that khamake uses node.js. This extends into how we script
  builds; rather than use a &quot;plain old data&quot; configuration
  file, we write a little bit of Javascript in a file called
  &quot;khafile.js&quot;. This file appears in the root of the project.
</para>
</sect1>
<sect1 id="khafile.js">
  <title>khafile.js</title>
  <programlisting language="javascript">
var project = new Project(&quot;Empty&quot;); // instance the project

project.addSources('Sources'); // add a source code path.
project.addAssets('Assets/**'); // add an asset path.
</programlisting>
  <para>
    Empty project doesn't have &quot;Assets&quot; by default.
  </para>
  <orderedlist spacing="compact">
    <listitem>
      <para>
        Add the addAssets line.
      </para>
    </listitem>
    <listitem>
      <para>
        Make an &quot;Assets&quot; directory, and drop
        <ulink url="https://github.com/triplefox/khaguide/blob/master/Empty/Assets/arial.ttf">arial.ttf</ulink> into Assets.
      </para>
    </listitem>
    <listitem>
      <para>
        Run khamake again.
      </para>
    </listitem>
  </orderedlist>
  <para>
    The Project API also lets you add compiler defines and external
    libraries. The relevant khamake source code can be viewed in
    &quot;Kha/Tools/khamake/Project.js&quot;.
  </para>
</sect1>
<sect1 id="code-changes">
  <title>Code changes</title>
  <para>
    Now that we have an asset, we also have to manage loading.
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Kha gives you a simple, blunt instrument to load things with:
        &quot;Assets.loadEverything()&quot;. The argument to
        loadEverything is a callback function for when the load is
        finished.
      </para>
    </listitem>
  </itemizedlist>
  <blockquote>
    <para>
      Assets also has other, more refined methods that let you pick and
      choose, but in a simple game that loads everything into memory
      once, this is the right solution. For the more complex case, each
      asset also has an unload() method, allowing you to move them in
      and out of memory as needed.
    </para>
  </blockquote>
  <itemizedlist>
    <listitem>
      <para>
        Once everything is loaded, we turn on a flag that lets the
        update and render callbacks progress.
      </para>
    </listitem>
    <listitem>
      <para>
        To actually display the text, set &quot;font&quot; and
        &quot;fontSize&quot; state on Graphics2, and then issue a
        drawString() command:
      </para>
      <para>
        drawString(s : String, x : Float, y : Float);
      </para>
    </listitem>
  </itemizedlist>
  <para>
    The string draws with the specified pixel at top-left. You can use
    the font.width(), font.height(), and font.baseline() attributes as
    building blocks for text formatting. Each of those sizing methods
    takes the font size as a parameter.
  </para>
  <blockquote>
    <para>
      The text colors differently when the bomb is dropped. This is a
      fun side-effect bug that I decided to leave in.
    </para>
  </blockquote>
  <sect2 id="empty.hx-8">
    <title>Empty.hx</title>
    <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;
import kha.Assets;

enum MapTile {
    MTNone;
    MTWall;
    MTRock;
}

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        Assets.loadEverything(function() { load_finished = true; startLevel(); } );
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    public static inline var ROCKFALL_TIMER = 4;
    
    public var load_finished = false;
    public var fire = false;
    var plane = { x:0., y:0., w:8., h:8., vx:2., vy:0. };
    var bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
    var map : Tilemap&lt;MapTile&gt;;
    var rockfall_time : Int;
    
    public function startLevel() {
        rockfall_time = 0;
        plane = { x:0., y:0., w:8., h:8., vx:1., vy:0. };
        bomb = { x:0., y:0., w:8., h:8., vx:0., vy:0., alive:false };
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = MTRock;
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        if (!load_finished) return;
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = Color.Orange;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                        case MTRock:
                            g.color = col_rock;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            { // render plane
                g.color = col_plane;
                g.fillRect(plane.x, plane.y, plane.w, plane.h);
            }
            if (bomb.alive) { // render bomb
                g.color = col_bomb;
                g.fillRect(bomb.x, bomb.y, bomb.w, bomb.h);
            }
            { // render some text
                g.font = Assets.fonts.arial;
                g.fontSize = 14;
                g.drawString(&quot;Canyon Bomber&quot;, 
                    WIDTH / 2 - g.font.width(14, &quot;Canyon Bomber&quot;) / 2,
                    8
                );
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function update(): Void {
        if (!load_finished) return;
        { // if we tapped the button spawn the bomb, if possible
            if (fire &amp;&amp; !bomb.alive)  {
                bomb.alive = true;
                bomb.x = plane.x;
                bomb.y = plane.y;
                bomb.vx = plane.vx;
                bomb.vy = 0.;
            }
        }
        { // advance plane movement
            plane.x += plane.vx;
            plane.y += plane.vy;
            // wrap around
            if (plane.x &gt; WIDTH)
                plane.x = -plane.w + 1;
            else if (plane.x &lt; -plane.w)
                plane.x = WIDTH + 1;
        }
        { // advance bomb movement
            if (bomb.alive) {
                bomb.vy += 0.2; // gravity
                bomb.x += bomb.vx;
                bomb.y += bomb.vy;
                var top = bomb.y;
                var left = bomb.x;
                var right = bomb.x + bomb.w;
                var bottom = bomb.y + bomb.h;
                var i0 = map.p2i(left, top);
                var i1 = map.p2i(right, top);
                var i2 = map.p2i(left, bottom);
                var i3 = map.p2i(right, bottom);
                bomb.alive = bomb.alive &amp;&amp; bombCollision(i0)
                                        &amp;&amp; bombCollision(i1)
                                        &amp;&amp; bombCollision(i2)
                                        &amp;&amp; bombCollision(i3);
                if (bomb.y &gt; HEIGHT) 
                    bomb.alive = false;
            }
        }
        if (rockfall_time &lt; 1) { // advance the rock fall
            rockfall_time = ROCKFALL_TIMER;
            for (y in 1...MAP_H) {
                var iy0 = (MAP_H - 1) - y; // rock to fall
                var iy1 = iy0 + 1; // tile underneath
                for (x in 0...MAP_W) {
                    var idx0 = map.i(x, iy0);
                    var idx1 = map.i(x, iy1);
                    if (map.d[idx0] == MTRock &amp;&amp; map.d[idx1] == MTNone) {
                        map.d[idx0] = MTNone;
                        map.d[idx1] = MTRock;
                    }
                }
            }
        } else {
            rockfall_time--;
        }
    }
    
    public function bombCollision(idx : Int) {
        if (idx &lt; 0 || idx &gt; map.d.length) return false;
        else switch(map.d[idx]) {
            case MTNone: return true;
            case MTWall: return false;
            case MTRock: map.d[idx] = MTNone; return true;
        }
    }
    
}
</programlisting>
  </sect2>
</sect1>
</chapter>





<chapter id="completing-the-game-loop">
<title>Completing the game loop</title>
<sect1>
<para>
  Now we add the scoring, lives, level progression, and game over state.
  A lot of meat gets added to the game logic in this section, but API
  calls do not really change. Review this section if you are interested
  in gameplay code, or if you need to compare against the later steps
  where more assets come in.
</para>
<para>
  To make the rocks score different values I introduce a parameter to
  MTRock. This changes our comparison code slightly, and opens up some
  options for rendering.
</para>
<blockquote>
  <para>
    Parameterization may change the performance characteristics of Enum
    values. If they have no parameters, you may typically consider them
    as integer constants - otherwise, think of the implementation as
    being similar to full object instances underneath. These details may
    change depending on the target you are working with.
  </para>
</blockquote>
<para>
  I made some adjustments to the plane motion so that it is more
  randomized, and at varying heights on each pass. The speed gradually
  ramps up over time now. (In the original game this is represented by
  switching from balloons to planes - maybe the wind picked up or
  something?) The bombs also now have a time/damage counter on them that
  limits their progress through the boulders.
</para>
<para>
  As I made these additions I also decided to model the game's entities
  with named Typedefs instead of anonymous objects, and iterate over an
  array of players instead of just one. This moves it a little bit more
  towards a final data model and will help if, for example, the original
  game's two-player mode were implemented(it isn't). It is not a
  flexible entity system and doesn't try to decouple the data(e.g. a
  collision structure used by both plane and bombs), but for this simple
  game it is sufficient.
</para>
<para>
  A &quot;real&quot; HUD now appears, since we're tracking scores and
  lives. One of the numerous challenges of adding multiplayer is the
  additional UI elements needed, and in this case I evade the problem by
  only looking at Player 1.
</para>
</sect1>
<sect1 id="empty.hx-9">
  <title>Empty.hx</title>
  <programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;
import kha.Assets;

enum MapTile {
    MTNone;
    MTWall;
    MTRock(value : Int);
}

typedef Plane = { x:Float, y:Float, 
    w:Float, h:Float, 
    vx:Float, vy:Float, 
    dropped:Bool, passes:Int
    };
typedef Bomb = { x:Float, y:Float, 
    w:Float, h:Float, 
    vx:Float, vy:Float, 
    alive:Bool, hit:Bool, hit_time:Int };
typedef Player = {
    score : Int, lives : Int,
    plane : Plane,
    bomb : Bomb
};

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        Assets.loadEverything(function() { load_finished = true; startGame(); game_over = true; } );
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    public static inline var ROCKFALL_TIMER = 4;
    public static inline var PLANE_MINY = Std.int(HEIGHT * 0.1);
    public static inline var PLANE_MAXY = Std.int(HEIGHT * 0.4);
    public static inline var BOMB_HIT_TIMER = 6;
    public static inline var BOMB_GRAVITY = 0.08;
    
    public var load_finished = false;
    public var fire = false;
    var player : Array&lt;Player&gt;;
    var map : Tilemap&lt;MapTile&gt;;
    var rockfall_time : Int;
    var game_over : Bool;
    var high_score : Int = 100;
    
    public function startGame() {
        player = [{ bomb:null, plane:null, score:0, lives:5 }];
        game_over = false;
        startLevel();
    }
    
    public function startLevel() {
        rockfall_time = 0;
        for (p in player) {
            p.plane = { x:0., y:0., w:8., h:8., vx:2., vy:0.,
                dropped:false, passes:0
            };
            respawnPlane(p.plane);
            p.bomb = { x:0., y:0., w:4., h:4., vx:0., vy:0., alive:false, hit:false,
                hit_time:BOMB_HIT_TIMER
            };
        }
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = // score based on depth
                        MTRock(Std.int((y - CANYON_Y + 1) * 5 / 
                            (MAP_H - CANYON_Y)));
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        if (!load_finished) return;
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = [Color.Orange, Color.Pink, Color.Purple, 
            Color.Red, Color.Cyan];
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                        case MTRock(v):
                            g.color = col_rock[v%5];
                            g.fillRect(x * TILE_W, y * TILE_H, TILE_W, TILE_H);
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            for (p in player) {
                { // render plane
                    g.color = col_plane;
                    g.fillRect(p.plane.x, p.plane.y, p.plane.w, p.plane.h);
                }
                if (p.bomb.alive) { // render bomb
                    g.color = col_bomb;
                    g.fillRect(p.bomb.x, p.bomb.y, p.bomb.w, p.bomb.h);
                }
            }
            { // render some text
                g.font = Assets.fonts.arial;
                g.fontSize = 14;
                if (game_over) {
                    g.drawString(
                        'Score ${player[0].score}  High ${high_score}',  
                        8, 8
                    );
                    var gotxt = 'Game Over';
                    g.drawString(
                        gotxt,  
                        WIDTH / 2 - g.font.width(14, gotxt) / 2,
                        HEIGHT / 2 - g.font.height(14) / 2
                    );
                } else {
                    g.drawString(
                        'Lives ${player[0].lives}  Score ${player[0].score}' +
                        '  High ${high_score}',  
                        8, 8
                    );
                }
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function outOfBounds(plane : Plane) {
        return (plane.x &gt; WIDTH + plane.w || plane.x &lt; -plane.w * 2);
    }
    public function respawnPlane(plane : Plane) {
        if (Math.random() &gt; 0.5) {
            plane.x = -plane.w + 1;
            plane.vx = 1;
        } else {
            plane.x = WIDTH + 1;
            plane.vx = -1;
        }
        plane.y = (Math.random() * (PLANE_MAXY - PLANE_MINY)) 
            + PLANE_MINY;
        plane.vx *= Math.min(0.5 + (plane.passes+1) * 0.15, 1.5);
    }
    
    public function update(): Void {
        if (!load_finished) return;
        for (p in player) {
            var bomb = p.bomb;
            var plane = p.plane;
            { // if we tapped the button spawn the bomb, if possible
                if (!game_over &amp;&amp; fire &amp;&amp; !bomb.alive &amp;&amp; p.lives &gt; 0)  {
                    bomb.alive = true;
                    bomb.x = plane.x + plane.w / 2 - bomb.w / 2;
                    bomb.y = plane.y + plane.h;
                    bomb.vx = plane.vx;
                    bomb.vy = 0.;
                    bomb.hit = false;
                    bomb.hit_time = BOMB_HIT_TIMER;
                    p.plane.dropped = true;
                } else if (fire &amp;&amp; game_over) {
                    startGame();
                }
            }
            { // advance plane movement
                plane.x += plane.vx;
                plane.y += plane.vy;
                // move plane into new passing position; end turn
                var turn_over = false;
                if (outOfBounds(plane) &amp;&amp; !bomb.alive)
                {
                    plane.passes += 1;
                    respawnPlane(plane);
                    turn_over = true;
                }
                if (turn_over &amp;&amp; !game_over) {
                    // test for whether turn was successful
                    if (!p.plane.dropped) {
                        p.lives -= 1;
                    }
                    p.plane.dropped = false;
                    // test for new level
                    var newlevel = true;
                    for (t in map.d) {
                        if (t.getIndex() == MTRock(0).getIndex()) {
                            newlevel = false;
                        }
                    }
                    if (newlevel) {
                        startLevel();
                    }
                    if (p.lives &lt; 1) {
                        game_over = true;
                        if (p.score &gt; high_score)
                            high_score = p.score;
                    }
                }
            }
            { // advance bomb movement
                if (bomb.alive) {
                    bomb.vy += BOMB_GRAVITY; // gravity
                    bomb.x += bomb.vx;
                    bomb.y += bomb.vy;
                    var top = bomb.y;
                    var left = bomb.x;
                    var right = bomb.x + bomb.w;
                    var bottom = bomb.y + bomb.h;
                    var i0 = map.p2i(left, top);
                    var i1 = map.p2i(right, top);
                    var i2 = map.p2i(left, bottom);
                    var i3 = map.p2i(right, bottom);
                    var damage = 0;
                    damage = Std.int(Math.max(damage, bombCollision(i0, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i1, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i2, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i3, p)));
                    bomb.hit_time -= damage;
                    if (bomb.hit_time &lt; 1) bomb.alive = false;
                    if (bomb.y &gt; HEIGHT)
                        bomb.alive = false;
                    if (!bomb.alive &amp;&amp; !bomb.hit)
                        p.lives -= 1;
                }
            }
        }
        if (rockfall_time &lt; 1) { // advance the rock fall
            rockfall_time = ROCKFALL_TIMER;
            for (y in 1...MAP_H) {
                var iy0 = (MAP_H - 1) - y; // rock to fall
                var iy1 = iy0 + 1; // tile underneath
                for (x in 0...MAP_W) {
                    var idx0 = map.i(x, iy0);
                    var idx1 = map.i(x, iy1);
                    if (map.d[idx0].getIndex() == Type.enumIndex(MTRock(0))
                        &amp;&amp; map.d[idx1] == MTNone)
                    {
                        map.d[idx1] = map.d[idx0];
                        map.d[idx0] = MTNone;
                    }
                }
            }
        } else {
            rockfall_time--;
        }
    }
    
    public function bombCollision(idx : Int, p : Player) : Int {
        if (idx &lt; 0 || idx &gt; map.d.length) return 0;
        else switch(map.d[idx]) {
            case MTNone: return 0;
            case MTWall: return BOMB_HIT_TIMER;
            case MTRock(v): map.d[idx] = MTNone; 
                p.score += v;
                p.bomb.hit = true;
                return 1;
        }
    }
    
}
</programlisting>
</sect1>
</chapter>


<chapter id="api-sprite-assets">
<title>API 6: Sprite Assets</title>
<sect1>
<para>
  Sprites are bitmap images that can be moved around the screen; they
  replace the rectangles we've been using up until this point. Adding
  sprites will make the game feel a lot less prototype-y. This is a big
  step and walks us through the asset creation process as well as code.
</para>
<para>
  First of all, we need to have some assets to work with.
</para>
<para>
  <ulink url="https://github.com/triplefox/khaguide/blob/master/Empty/Assets/sprites.png">sprites.png</ulink>
</para>
<para>
  I drew up a mockup with some simple sprites and tiles, based on the
  original game, but adding a little more detail.
</para>
<para>
  Now, we have a few options for turning this mockup into usable assets.
  Kha will take care of converting and packaging the image when we
  run khamake. But we still need to assign &quot;meanings&quot;
  to the assets that make them equivalent to the rectangles we've been
  using up until now.
</para>
<itemizedlist spacing="compact">
  <listitem>
    <para>
      We could split it into one image for each asset, and refer to
      different files.
    </para>
  </listitem>
  <listitem>
    <para>
      We could realign them in a simple tile pattern, and then index by
      the tile number.
    </para>
  </listitem>
  <listitem>
    <para>
      Or we could define bounding boxes on the original image.
    </para>
  </listitem>
</itemizedlist>
<para>
  I'm going to take this last approach, using my own tool,
  <ulink url="http://triplefox.itch.io/pixelbound">Pixelbound</ulink>.
  It's free(or pay what you want) and comes with source code. Pixelbound
  makes it very simple to define bounding boxes on mockups. This also
  has the benefit of letting me specify collision boxes independently of
  the sprite, if I want.
</para>
<para>
  The output of Pixelbound is a JSON file containing some coordinates:
</para>
<ulink url="https://github.com/triplefox/khaguide/blob/master/Empty/Assets/spritedata.json">spritedata.json</ulink>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Now I take both of these files and add them to
        &quot;Assets&quot;.
      </para>
    </listitem>
    <listitem>
      <para>
        Since we populated khafile.js when we added the font, we can run
        khamake now to add them to the project build.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    Finally, we write some library code to parse the JSON into
    easily-accessed assets, and build some drawing functionality that
    lets us easily swap out our existing code:
  </para>
</sect1>
<sect1 id="boundsdata.hx">
  <title>BoundsData.hx</title>
  <programlisting language="haxe">
import haxe.Json;
import kha.FastFloat;
import kha.graphics2.Graphics;
import kha.Image;
class BoundsImage {
    public var names : Array&lt;String&gt;;
    public var rects : Array&lt;Array&lt;Int&gt;&gt;;
    public var names_map : Map&lt;String, Int&gt;;
    public var image_relative : String;
    public var image_absolute : String;
    public function new() {
        
    }
    public function updateCache() {
        names_map = new Map();
        for (i0 in 0...names.length) {
            names_map.set(names[i0], i0);
        }
    }
    public inline function nameToRect(name : String, ?offset : Int=0) {
        return rects[names_map.get(name)+offset];
    }   
}

class BoundsData {
    public var images : Array&lt;BoundsImage&gt;;
    public var palette : Array&lt;Array&lt;Int&gt;&gt;;
    
    public function new(data : String)
    {
        var jd = Json.parse(data);
        this.palette = jd.palette;
        this.images = [];
        for (img in cast(jd.images,Array&lt;Dynamic&gt;)) {
            var rimg = new BoundsImage();
            rimg.names = img.names;
            rimg.rects = img.rects;
            rimg.image_relative = img.image_relative;
            rimg.image_absolute = img.image_absolute;
            rimg.updateCache();
            this.images.push(rimg);
        }
    }
}

typedef FontData = { font_name : String,
    image_idx : Int, sprite_name:String, characters:String,
    whitespace : Int
    };

class KhaBoundsData {
    public var boundsdata : BoundsData;
    public var images : Array&lt;Image&gt;;
    public var fonts : Map&lt;String, FontData&gt;;
    public var font_cache : Map&lt;String, Map&lt;Int, Int&gt;&gt;;
    public function new( data : String, images : Array&lt;Image&gt;,
        fonts : Array&lt;FontData&gt;) {
        this.boundsdata = new BoundsData(data);
        this.images = images;
        this.fonts = new Map();
        for (n in fonts) this.fonts.set(n.font_name, n);
        this.font_cache = new Map();
        for (f0 in fonts) {
            var f1 = new Map&lt;Int, Int&gt;();
            for (o in 0...f0.characters.length) {
                var dest = o;
                var src = f0.characters.charCodeAt(o);
                f1.set(src, 
                boundsdata.images[f0.image_idx].names_map.get(
                    f0.sprite_name) + dest);                
            }
            font_cache.set(f0.font_name, f1);
        }
    }
    public inline function draw(g2 : Graphics, x : FastFloat, y : FastFloat, 
        image_idx : Int, sprite_name : String, ?sprite_offset : Int=0)
    {
        var bound = get(image_idx, sprite_name, sprite_offset);
        g2.drawSubImage(images[image_idx], 
            x, y, bound[0], bound[1], bound[2], bound[3]);
    }
    public inline function drawCenter(g2 : Graphics, 
        x : FastFloat, y : FastFloat,
        w : FastFloat, h : FastFloat,
        image_idx : Int, sprite_name : String, ?sprite_offset : Int = 0)
    {
        var bound = get(image_idx, sprite_name, sprite_offset);
        var cx = x + w / 2 - bound[2] / 2;
        var cy = y + h / 2 - bound[3] / 2;
        g2.drawSubImage(images[image_idx], 
            cx, cy, bound[0], bound[1], bound[2], bound[3]);
    }
    public inline function drawCenterScaled(g2 : Graphics, 
        x : FastFloat, y : FastFloat,
        w : FastFloat, h : FastFloat,
        sw : FastFloat, sh : FastFloat,
        image_idx : Int, sprite_name : String, ?sprite_offset : Int = 0)
    {
        var bound = get(image_idx, sprite_name, sprite_offset);
        var dw = bound[2] * sw;
        var dh = bound[3] * sh;
        var cx = x + w / 2 - dw / 2;
        var cy = y + h / 2 - dh / 2;
        g2.drawScaledSubImage(images[image_idx], 
            bound[0], bound[1], bound[2], bound[3], cx, cy, 
            dw, dh);
    }
    public inline function get(image_idx : Int, sprite_name : String, 
        ?sprite_offset : Int=0)
    {
        return boundsdata.images[image_idx].nameToRect(sprite_name, 
            sprite_offset);
    }
    public inline function stringWidth(text : String, font : String,
        spacing : Int) {
        var f0 = fonts.get(font);
        var f1 = font_cache.get(font);
        var result = 0;
        for (i0 in 0...text.length) {
            var c = text.charCodeAt(i0);
            if (f1.exists(c)) {
                var bd = boundsdata.images[f0.image_idx].rects[f1.get(c)];
                result += bd[2];
            } else if (c == ' '.charCodeAt(0)) {
                result += f0.whitespace;
            }
            if (i0 &lt; text.length-1)
                result += spacing;
        }
        return result;
    }
    public inline function stringHeight(text : String, font : String) {
        var f0 = fonts.get(font);
        var f1 = font_cache.get(font);
        var result = 0;
        for (i0 in 0...text.length) {
            var c = text.charCodeAt(i0);
            if (f1.exists(c)) {
                var bd = boundsdata.images[f0.image_idx].rects[f1.get(c)];
                if (bd[3] &gt; result) result = bd[3];
            }
        }
        return result;
    }
    public inline function string(g2 : Graphics, x : Int, y : Int,
        text : String, font : String,
        spacing : Int) {
        var f0 = fonts.get(font);
        var f1 = font_cache.get(font);
        for (i0 in 0...text.length) {
            var c = text.charCodeAt(i0);
            if (f1.exists(c)) {
                var bd = boundsdata.images[f0.image_idx].rects[f1.get(c)];
                var img = images[f0.image_idx];
                g2.drawSubImage(img, x, y, bd[0], bd[1], bd[2], bd[3]); 
                x += bd[2];
            } else if (c == ' '.charCodeAt(0)) {
                x += f0.whitespace;
            }
            if (i0 &lt; text.length-1)
                x += spacing;
        }
    }   
}
</programlisting>
  <para>
    In the main code, we replace the sprite calls, add some branching to
    switch between plane/blimp and mirror them for the correct
    direction, add a &quot;smoothing&quot; process to the walls so that
    the diagonals look nicer, add an explosion &quot;particle&quot;, and
    replace the Kha font calls with our cool bitmapped font. Whew!
    Adding graphics sure does require a lot of code!
  </para>
  <para>
    Let's break each of those things down:
  </para>
</sect1>
<sect1 id="drawing-plane-blimp-and-bomb">
  <title>Drawing Plane, Blimp, and Bomb</title>
  <para>
    This is the simplest kind of sprite drawing: take some coordinates
    and throw an image up on the screen. It's only different from the
    rectangle drawing in that we're going to conform to the size of the
    sprite (and we don't even have to do that, necessarily, if we scale
    the sprite).
  </para>
  <para>
    We also mirror the plane and blimp. This is done by scaling the
    sprite with a negative X value.
  </para>
  <para>
    We can reuse all of our coloring code because I had the foresight to
    design the sprites to be grayscale, meaning we have a very colorful
    game without much effort!
  </para>
  <blockquote>
    <para>
      As explained in the Graphics2 API section, if you find the look of
      the scaling to be &quot;wrong,&quot; try switching from using
      transforms on FastMatrix3 to using a backbuffer at your preferred
      resolution.
    </para>
  </blockquote>
  <para>
    To access spritedata.json we use the Blob API. khamake appends the file 
    extension to these assets as an underscore, so the field name is "spritedata_json".
  </para>
</sect1>
<sect1 id="smoothing-the-walls">
  <title>Smoothing the Walls</title>
  <para>
    Now we have more of a &quot;real&quot; tilemap situation, where some
    tiles look different from others but share the same behaviors. One
    way we could approach the problem is to separate the visuals from
    the collision entirely - this is done by most games. But the simpler
    way for our game is to add a few more values to the Enum, and then
    update the corresponding switch statements to either behave the same
    way or render something different.
  </para>
  <para>
    Then the only thing left to do is to actually populate the walls
    correctly, which is done in an additional pass after the original
    canyon generation process finishes.
  </para>
</sect1>
<sect1 id="add-a-particle">
  <title>Add a Particle</title>
  <para>
    Real particle effects tend to involve some kind of particle
    simulation that can produce fluid-like effects like smoke, flames,
    bubbles, etc. Again, we can simplify to &quot;basic&quot; particle
    programs whose instances hold a position and velocity state. We only
    use one type here to add little puffs when the rocks are broken, but
    more are certainly possible! And because we are using Haxe's enums,
    we can pass parameters into the program so that each instance of the
    particles may behave a bit differently.
  </para>
  <para>
    The way in which I spawn particles is also interesting and relevant
    to any case in a game where there is a &quot;more than one&quot; in
    the world. I assume that we will only ever have 64 particles at
    most, and allocate all of them. Then I process all of them each
    frame, using their timer value to determine liveness. This is a
    crude technique to avoid triggering garbage collection - just
    instance a pool of our maximum number, and never add to or remove
    from the pool. This limits what happens if the system is pressured
    with a lot of particles - it'll just stop spawning more. It also
    gives me a realistic measure of maximium system throughput. If I'm
    already iterating on my maximum quantity, then I can't be fooled
    into thinking I have &quot;room to waste.&quot;
  </para>
</sect1>
<sect1 id="bitmap-font">
  <title>Bitmap Font</title>
  <para>
    The font data is the most complex part of this whole rendering
    operation. The font rendering pipeline builds on top of the sprite
    rendering pipeline, but it has the complication of needing to map
    each character of the string to a sprite. It works by mapping a
    given set of characters such as &quot;ABCDEF...&quot; to sprite
    indexes, starting from a certain named sprite.
  </para>
  <para>
    I decided, after I had created them, to combine the
    &quot;alphabet&quot; and &quot;number&quot; groups into one
    continuous set each, which led to some manual rearrangement of the
    rectangles Pixelbound auto-generates so that they were in the proper
    order. Pixelbound doesn't have a group offset feature, but I was
    able to make the change by editing the JSON text.
  </para>
  <para>
    After doing all that work to configure the data, the rest is a
    matter of computing widths for each character based on the sprite
    data, and then adding some spacing. A more complex font engine can
    extend to additional layout, effects, more precise spacing and
    kerning, etc. The game includes some basic layout features in
    string() and centerString() - it uses the two &quot;alphabets&quot;
    to make a shadow offset effect.
  </para>
</sect1>
<sect1 id="why-use-a-single-image-for-many-sprites">
  <title>Why use a single image for many sprites?</title>
  <para>
    One of the benefits of using a single image for all the sprites, if
    you aren't aware, is that GPU drawing can be optimized. In the
    jargon of GPU programming, a &quot;texture&quot; is referenced
    before beginning a &quot;draw call&quot;. During a draw call, you
    send a &quot;batch&quot; of geometry data - coordinates, offsets,
    etc. If you don't have to switch textures, the only unique thing the
    GPU has to process is geometry. Draw calls are a major bottleneck
    because they cause the GPU to idle, and the stop-start of frequent
    draw calls will kill performance.
  </para>
  <para>
    Therefore, the use of sprite sheets is one of the first
    optimizations encountered in 2D GPU drawing, and well-optimized 2D
    games will &quot;pack&quot; their sprites tightly in sheets so as to
    minimize draw calls. (This can be done by hand or by algorithm.)
  </para>
  <para>
    Graphics2 will do the behind-the-scenes work of optimizing your draw
    calls when you use drawSubImage() and its variants, so you don't
    have to know any more than that basic outline to get most of the
    benefit when working with Kha for 2D games.
  </para>
</sect1>
<sect1 id="what-if-i-want-to-upgrade-to-graphics4-later">
  <title>What if I want to upgrade to Graphics4 later?</title>
  <para>
    Direct quote from Robert:
  </para>
  <blockquote>
    <para>
      <emphasis>g2 runs on g4 and can be mixed with g4 if your target
      supports g4 (most important exceptions are browsers that don't
      support webgl or don't activate it because of black-listed
      drivers).</emphasis>
    </para>
  </blockquote>
  <blockquote>
    <para>
      <emphasis>But g4 is a completely different thing than g2 and needs
      a much bigger skillset. There are 
    <ulink url="http://luboslenco.com/kha3d/">Lubos' tutorials</ulink>
      though.</emphasis>
    </para>
  </blockquote>
  <blockquote>
    <para>
      <emphasis>Oh and don't expect any speed improvements from d3d12.
      d3d12 (and vulkan) is about low level control, not about magic
      speed improvements.</emphasis>
    </para>
  </blockquote>
<blockquote>
    <para>
      <emphasis>
        For mixing g2 and g4 have a closer look at kha.graphics4.Graphics2. 
        Mostly it's important to call g2.flush at the right times.</emphasis>
    </para>
</blockquote>
</sect1>
<sect1 id="empty.hx-10">
<title>Empty.hx</title>
<programlisting language="haxe">
package;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;
import kha.Assets;
import BoundsData;

enum MapTile {
    MTNone;
    MTWall;
    MTWallTL;
    MTWallTR;
    MTRock(value : Int);
}
enum ParticleProgram {
    Explosion;
}

typedef Plane = { x:Float, y:Float, 
    w:Float, h:Float, 
    vx:Float, vy:Float, 
    dropped:Bool, passes:Int
    };
typedef Bomb = { x:Float, y:Float, 
    w:Float, h:Float, 
    vx:Float, vy:Float, 
    alive:Bool, hit:Bool, hit_time:Int };
typedef Player = {
    score : Int, lives : Int,
    plane : Plane,
    bomb : Bomb
};
typedef Particle = {
    x : Float, y : Float,
    time : Int,
    program : ParticleProgram,
    sprite_image : Int,
    sprite_name : String
};

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        Assets.loadEverything(function() { load_finished = true; startGame(); game_over = true; } );
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    public static inline var ROCKFALL_TIMER = 4;
    public static inline var PLANE_MINY = Std.int(HEIGHT * 0.1);
    public static inline var PLANE_MAXY = Std.int(HEIGHT * 0.4);
    public static inline var BOMB_HIT_TIMER = 6;
    public static inline var BOMB_GRAVITY = 0.08;
    public static inline var EXPLODE_0 = 10 * 4/4;
    public static inline var EXPLODE_1 = 10 * 3/4;
    public static inline var EXPLODE_2 = 10 * 2/4;
    public static inline var EXPLODE_3 = 10 * 1/4;
    public static inline var IS_BLIMP_UNTIL_VX = 1.0;
    
    public var load_finished = false;
    public var fire = false;
    var player : Array&lt;Player&gt;;
    var map : Tilemap&lt;MapTile&gt;;
    var rockfall_time : Int;
    var game_over : Bool;
    var high_score : Int = 100;
    var particle : Array&lt;Particle&gt;;
    var sprite : KhaBoundsData;
    
    public function startGame() {
        player = [{ bomb:null, plane:null, score:0, lives:5 }];
        game_over = false;
        particle = [for (n in 0...64) 
            {x:0., y:0., program:Explosion, time: -1, 
            sprite_image:0, sprite_name:null}
        ];
        sprite = new KhaBoundsData(
            Assets.blobs.spritedata_json.toString(),
            [Assets.images.sprites],
            [
            {
                font_name:&quot;alphabet1&quot;,
                image_idx:0,
                sprite_name:&quot;alphabet1&quot;,
                characters:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;,
                whitespace:4
            },
            {
                font_name:&quot;alphabet2&quot;,
                image_idx:0,
                sprite_name:&quot;alphabet2&quot;,
                characters:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;,
                whitespace:4
            }
            ]
            );
        startLevel();
    }
    
    public function startLevel() {
        rockfall_time = 0;
        for (p in player) {
            p.plane = { x:0., y:0., w:8., h:8., vx:2., vy:0.,
                dropped:false, passes:0
            };
            respawnPlane(p.plane);
            p.bomb = { x:0., y:0., w:4., h:4., vx:0., vy:0., alive:false, hit:false,
                hit_time:BOMB_HIT_TIMER
            };
        }
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = // score based on depth
                        MTRock(Std.int((y - CANYON_Y + 1) * 5 / 
                            (MAP_H - CANYON_Y)));
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
        for (y in 0...map.h) { // smooth canyon
            for (x in 0...map.w) {
                var idx = map.i(x, y);
                if (map.d[idx] == MTWall &amp;&amp; 
                    y &gt; 0 &amp;&amp; 
                    map.d[idx - MAP_W] != MTWall &amp;&amp;
                    map.d[idx - MAP_W] != MTWallTL &amp;&amp;
                    map.d[idx - MAP_W] != MTWallTR
                    ) {
                    if (x &gt; 0 &amp;&amp; map.d[idx - 1] != MTWall &amp;&amp;
                        map.d[idx - 1] != MTWallTL &amp;&amp;
                        map.d[idx - 1] != MTWallTR)
                        map.d[idx] = MTWallTL;
                    else if (x &lt; map.w - 1 &amp;&amp; 
                        map.d[idx + 1] != MTWall &amp;&amp;
                        map.d[idx + 1] != MTWallTL &amp;&amp;
                        map.d[idx + 1] != MTWallTR)
                        map.d[idx] = MTWallTR;
                }
            }
        }       
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        if (!load_finished) return;
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = [Color.Orange, Color.Pink, Color.Purple, 
            Color.Red, Color.Cyan];
        var col_explosion = Color.White;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;block&quot;);
                        case MTWallTL:
                            g.color = col_wall;
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;blocktl&quot;);
                        case MTWallTR:
                            g.color = col_wall;
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;blocktr&quot;);
                        case MTRock(v):
                            g.color = col_rock[v%5];
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;boulder&quot;);                          
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            for (p in player) {
                { // render plane
                    g.color = col_plane;
                    var mirror = 1;
                    var plane = p.plane;
                    if (plane.vx &lt; 0) mirror = -1;
                    var spr = &quot;plane&quot;;
                    if (isBlimp(plane))
                        spr = &quot;blimp&quot;;
                    sprite.drawCenterScaled(g, plane.x, plane.y,
                        plane.w, plane.h, 
                        mirror, 1, 0, spr);
                }
                if (p.bomb.alive) { // render bomb
                    var bomb = p.bomb;
                    g.color = col_bomb;
                    sprite.drawCenter(g, bomb.x, bomb.y, bomb.w, bomb.h, 
                        0, &quot;bomb&quot;);
                }
            }
            for (p in particle) { // render particles
                if (p.time &gt; 0) {
                    g.color = col_explosion;
                    sprite.draw(g, p.x, p.y, p.sprite_image, p.sprite_name);
                }
            }
            { // render some text
                if (game_over) {
                    string(
                        g, 'SCORE ${player[0].score}     HIGH ${high_score}',
                        8, 8, 1
                    );
                    var gotxt = 'Game Over'.toUpperCase();
                    centerString(
                        g, 
                        gotxt,
                        WIDTH / 2,
                        HEIGHT / 2,
                        1
                    );
                } else {
                    string(
                        g,
                        'LIVES ${player[0].lives}     SCORE ${player[0].score}' +
                        '     HIGH ${high_score}',  
                        8, 8, 1
                    );
                }
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function outOfBounds(plane : Plane) {
        return (plane.x &gt; WIDTH + plane.w || plane.x &lt; -plane.w * 2);
    }
    public function respawnPlane(plane : Plane) {
        if (Math.random() &gt; 0.5) {
            plane.x = -plane.w + 1;
            plane.vx = 1;
        } else {
            plane.x = WIDTH + 1;
            plane.vx = -1;
        }
        plane.y = (Math.random() * (PLANE_MAXY - PLANE_MINY)) 
            + PLANE_MINY;
        plane.vx *= Math.min(0.5 + (plane.passes+1) * 0.15, 1.5);
    }
    
    public function update(): Void {
        if (!load_finished) return;
        for (p in player) {
            var bomb = p.bomb;
            var plane = p.plane;
            { // if we tapped the button spawn the bomb, if possible
                if (!game_over &amp;&amp; fire &amp;&amp; !bomb.alive &amp;&amp; p.lives &gt; 0)  {
                    bomb.alive = true;
                    bomb.x = plane.x + plane.w / 2 - bomb.w / 2;
                    bomb.y = plane.y + plane.h;
                    bomb.vx = plane.vx;
                    bomb.vy = 0.;
                    bomb.hit = false;
                    bomb.hit_time = BOMB_HIT_TIMER;
                    p.plane.dropped = true;
                } else if (fire &amp;&amp; game_over) {
                    startGame();
                }
            }
            { // advance plane movement
                plane.x += plane.vx;
                plane.y += plane.vy;
                // move plane into new passing position; end turn
                var turn_over = false;
                if (outOfBounds(plane) &amp;&amp; !bomb.alive)
                {
                    plane.passes += 1;
                    respawnPlane(plane);
                    turn_over = true;
                }
                if (turn_over &amp;&amp; !game_over) {
                    // test for whether turn was successful
                    if (!p.plane.dropped) {
                        p.lives -= 1;
                    }
                    p.plane.dropped = false;
                    // test for new level
                    var newlevel = true;
                    for (t in map.d) {
                        if (t.getIndex() == MTRock(0).getIndex()) {
                            newlevel = false;
                        }
                    }
                    if (newlevel) {
                        startLevel();
                    }
                    if (p.lives &lt; 1) {
                        game_over = true;
                        if (p.score &gt; high_score)
                            high_score = p.score;
                    }
                }
            }
            { // advance bomb movement
                if (bomb.alive) {
                    bomb.vy += BOMB_GRAVITY; // gravity
                    bomb.x += bomb.vx;
                    bomb.y += bomb.vy;
                    var top = bomb.y;
                    var left = bomb.x;
                    var right = bomb.x + bomb.w;
                    var bottom = bomb.y + bomb.h;
                    var i0 = map.p2i(left, top);
                    var i1 = map.p2i(right, top);
                    var i2 = map.p2i(left, bottom);
                    var i3 = map.p2i(right, bottom);
                    var damage = 0;
                    damage = Std.int(Math.max(damage, bombCollision(i0, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i1, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i2, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i3, p)));
                    bomb.hit_time -= damage;
                    if (bomb.hit_time &lt; 1) bomb.alive = false;
                    if (bomb.y &gt; HEIGHT)
                        bomb.alive = false;
                    if (!bomb.alive &amp;&amp; !bomb.hit)
                        p.lives -= 1;
                }
            }
        }
        if (rockfall_time &lt; 1) { // advance the rock fall
            rockfall_time = ROCKFALL_TIMER;
            for (y in 1...MAP_H) {
                var iy0 = (MAP_H - 1) - y; // rock to fall
                var iy1 = iy0 + 1; // tile underneath
                for (x in 0...MAP_W) {
                    var idx0 = map.i(x, iy0);
                    var idx1 = map.i(x, iy1);
                    if (map.d[idx0].getIndex() == Type.enumIndex(MTRock(0))
                        &amp;&amp; map.d[idx1] == MTNone)
                    {
                        map.d[idx1] = map.d[idx0];
                        map.d[idx0] = MTNone;
                    }
                }
            }
        } else {
            rockfall_time--;
        }
        for (p in particle) { // particle simulation
            if (p.time &gt; 0) {
                switch(p.program) { // run particle program
                    case Explosion:
                        p.sprite_image = 0;
                        if (p.time &gt; EXPLODE_1) {
                            p.sprite_name = &quot;explosion1&quot;;
                        }
                        else if (p.time &gt; EXPLODE_2) {
                            p.sprite_name = &quot;explosion2&quot;;
                        }
                        else if (p.time &gt; EXPLODE_3) {
                            p.sprite_name = &quot;explosion3&quot;;
                        }
                        else {
                            p.sprite_name = &quot;explosion4&quot;;
                        }
                        p.y -= 0.2;
                }
                p.time -= 1;
            }
        }
    }
    
    public function bombCollision(idx : Int, p : Player) : Int {
        if (idx &lt; 0 || idx &gt; map.d.length) return 0;
        else switch(map.d[idx]) {
            case MTNone: return 0;
            case MTWall, MTWallTL, MTWallTR: return BOMB_HIT_TIMER;
            case MTRock(v): map.d[idx] = MTNone; 
                p.score += v;
                p.bomb.hit = true;
                spawnParticle(
                    map.x2p(map.x(idx)), 
                    map.y2p(map.y(idx)), Explosion);
                return 1;
        }
    }
    
    public function spawnParticle(x : Float, y : Float, program : ParticleProgram) {
        for (pi in 0...particle.length) {
            var p = particle[pi];
            if (p.time &lt;= 0) {
                p.program = program;
                p.x = x;
                p.y = y;
                switch(program) {
                    case Explosion:
                        p.time = Std.int(EXPLODE_0 + Math.random() * 6);
                }
                return pi;
            }
        }
        return -1;
    }
    
    public function isBlimp(p : Plane) {
        return (Math.abs(p.vx) &lt; IS_BLIMP_UNTIL_VX);
    }
    
    public function string(g, s, x : Float, y : Float, spacing) {
        sprite.string(
            g, 
            Std.int(x + 1),
            Std.int(y + 1),
            s,
            &quot;alphabet2&quot;, spacing
        );
        sprite.string(
            g, 
            Std.int(x),
            Std.int(y),
            s,
            &quot;alphabet1&quot;, spacing
        );
    }
    public function centerString(g, s, x : Float, y : Float, spacing) {
        sprite.string(
            g, 
            Std.int(x - sprite.stringWidth(s, &quot;alphabet2&quot;, spacing) / 2 + 1),
            Std.int(y - sprite.stringHeight(s, &quot;alphabet2&quot;) / 2 + 1),
            s,
            &quot;alphabet2&quot;, spacing
        );
        sprite.string(
            g, 
            Std.int(x - sprite.stringWidth(s, &quot;alphabet1&quot;, spacing) / 2),
            Std.int(y - sprite.stringHeight(s, &quot;alphabet1&quot;) / 2),
            s,
            &quot;alphabet1&quot;, spacing
        );
    }
    
}
</programlisting>
</sect1>
</chapter>


<chapter id="api-sound-effects">
<title>API 7: Sound Effects</title>
<sect1>
<para>
  As with graphics, Kha has multiple &quot;levels&quot; of audio API.
  Unlike graphics, they don't exactly build on each other. Audio1 is a
  simplified &quot;recorded sound and music playback&quot; routine,
  while Audio2 is a &quot;write your own sample data&quot; low-level
  system. We'll stick with Audio1 here.
</para>
<para>
  First, I figured out a rough asset list and recruited my friend,
  <ulink url="s.hryx.net">Stevie Hryciw</ulink>, to make some sound
  effects and music. I initially targeted these:
</para>
<itemizedlist spacing="compact">
  <listitem>
    <para>
      drop - when you trigger a bomb drop
    </para>
  </listitem>
  <listitem>
    <para>
      hit - the bomb succeeded
    </para>
  </listitem>
  <listitem>
    <para>
      miss - the bomb missed (or you lost a life)
    </para>
  </listitem>
  <listitem>
    <para>
      break - a rock is broken
    </para>
  </listitem>
  <listitem>
    <para>
      music - a background soundtrack
    </para>
  </listitem>
</itemizedlist>
<para>
  Before I had these assets I made a simple sine wave sample using
  Audacity and copied that as a placeholder.
</para>
<para>
  After our first session, we had changed and expanded the asset list
  considerably to accommodate variations of similar sounds like the
  dropping and breaking noises. As tends to happen, the filenames also
  drifted away from my original scheme, so I updated the project to
  match. The final files(along with the other assets) are 
  <ulink url="https://github.com/triplefox/khaguide/tree/master/Empty/Assets">here</ulink>.
</para>
<para>
  Integrating audio into the project can be time-consuming, just like
  graphical effects. Most of the fancy usage of Audio1 here revolves
  around cancelling sounds so that they cut off(the bomb falling) or
  aren't doubling up(the rock breaking sounds). The plane and blimp have
  a sound loop with volume that is modulated over time, so that they get
  louder as they get near the center of the screen.
</para>
<para>
  FIXME TODO try to use the right API calls everywhere and not my cheap
  hacks
</para>
</sect1>
<sect1 id="sound">
  <title>Sound</title>
  <para>
    This is the asset type you use - you normally don't need to deal
    with it directly since the assets are baked into
    &quot;Assets.sound&quot;.
  </para>
</sect1>
<sect1 id="audio1.audio">
  <title>audio1.Audio</title>
  <programlisting>
Audio.play(sound : Sound, loop : Bool, stream : Bool) : AudioChannel;
</programlisting>
  <para>
    Usually call Audio.play(Assets.sound.mysound) for a basic
    one-shot sound.
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        If the sound is meant to loop, set &quot;loop&quot; to true.
      </para>
    </listitem>
    <listitem>
      <para>
        If the sound is a very large asset like music, set
        &quot;stream&quot; to true so that you aren't loading the whole
        thing into memory at once.
      </para>
    </listitem>
  </itemizedlist>
</sect1>
<sect1 id="audio1.audiochannel">
  <title>audio1.AudioChannel</title>
  <para>
    AudioChannel is returned after you start playing a Sound and
    contains some useful information about the state of the sound's
    playback: its volume, current sample position, length, and whether
    it's finished. If you care about these things, keep the instance
    around to monitor and modulate its parameters. The instances of
    AudioChannel in Canyon Bomber are used to keep track of loops and
    sounds that will need to be cancelled.
  </para>
</sect1>
<sect1 id="empty.hx-11">
<title>Empty.hx</title>
<programlisting language="haxe">
package;
import kha.audio1.Audio;
import kha.audio1.AudioChannel;
import kha.Framebuffer;
import kha.Color;
import kha.input.Keyboard;
import kha.input.Mouse;
import kha.Key;
import kha.math.FastMatrix3;
import kha.System;
import kha.Assets;
import BoundsData;
import kha.Sound;

enum MapTile {
    MTNone;
    MTWall;
    MTWallTL;
    MTWallTR;
    MTRock(value : Int);
}
enum ParticleProgram {
    Explosion;
}

typedef Plane = { x:Float, y:Float, 
    w:Float, h:Float, 
    vx:Float, vy:Float, 
    dropped:Bool, passes:Int
    };
typedef Bomb = { x:Float, y:Float, 
    w:Float, h:Float, 
    vx:Float, vy:Float, 
    alive:Bool, hit:Bool, hit_time:Int };
typedef Player = {
    score : Int, lives : Int,
    plane : Plane,
    bomb : Bomb
};
typedef Particle = {
    x : Float, y : Float,
    time : Int,
    program : ParticleProgram,
    sprite_image : Int,
    sprite_name : String
};

class Empty {
    public function new() {
        if (Keyboard.get() != null) Keyboard.get().notify(onDown,onUp);
        if (Mouse.get() != null) Mouse.get().notify(onDownMouse, onUpMouse, null, null);
        Assets.loadEverything(function() { load_finished = true; startGame(); game_over = true; } );
    }
    
    public static inline var WIDTH = 320;
    public static inline var HEIGHT = 240;
    
    public static inline var TILE_W = 8;
    public static inline var TILE_H = 8;
    public static inline var MAP_W = Std.int(WIDTH / TILE_W);
    public static inline var MAP_H = Std.int(HEIGHT / TILE_H);
    public static inline var CANYON_Y = Std.int(MAP_H / 2);
    public static inline var ROCKFALL_TIMER = 4;
    public static inline var PLANE_MINY = Std.int(HEIGHT * 0.1);
    public static inline var PLANE_MAXY = Std.int(HEIGHT * 0.4);
    public static inline var BOMB_HIT_TIMER = 6;
    public static inline var BOMB_GRAVITY = 0.08;
    public static inline var EXPLODE_0 = 10 * 4/4;
    public static inline var EXPLODE_1 = 10 * 3/4;
    public static inline var EXPLODE_2 = 10 * 2/4;
    public static inline var EXPLODE_3 = 10 * 1/4;
    public static inline var IS_BLIMP_UNTIL_VX = 1.0;
    
    public var load_finished = false;
    public var fire = false;
    var player : Array&lt;Player&gt;;
    var map : Tilemap&lt;MapTile&gt;;
    var rockfall_time : Int;
    var game_over : Bool;
    var high_score : Int = 100;
    var particle : Array&lt;Particle&gt;;
    var sprite : KhaBoundsData;
    var sound_bomb : Array&lt;String&gt;;
    var sound_explode : Array&lt;String&gt;;
    var channel_engine_blimp : AudioChannel;
    var channel_engine_plane : AudioChannel;
    var channel_drop : AudioChannel;
    var channel_break : AudioChannel;
    
    public function startGame() {
        player = [{ bomb:null, plane:null, score:0, lives:5 }];
        game_over = false;
        particle = [for (n in 0...64) 
            {x:0., y:0., program:Explosion, time: -1, 
            sprite_image:0, sprite_name:null}
        ];
        sound_bomb = [for (i in 0...4) ('bomb${i+1}')];
        sound_explode = [for (i in 0...12) ('explode${i+1}')];
        sprite = new KhaBoundsData(
            Assets.blobs.spritedata_json.toString(),
            [Assets.images.sprites],
            [
            {
                font_name:&quot;alphabet1&quot;,
                image_idx:0,
                sprite_name:&quot;alphabet1&quot;,
                characters:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;,
                whitespace:4
            },
            {
                font_name:&quot;alphabet2&quot;,
                image_idx:0,
                sprite_name:&quot;alphabet2&quot;,
                characters:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;,
                whitespace:4
            }
            ]
            );
        startLevel();
    }
    
    public function startLevel() {
        rockfall_time = 0;
        for (p in player) {
            p.plane = { x:0., y:0., w:8., h:8., vx:2., vy:0.,
                dropped:false, passes:0
            };
            respawnPlane(p.plane);
            p.bomb = { x:0., y:0., w:4., h:4., vx:0., vy:0., alive:false, hit:false,
                hit_time:BOMB_HIT_TIMER
            };
        }
        fire = false;
        map = new Tilemap(MAP_W, MAP_H, TILE_W, TILE_H, MTNone); // initial sizing
        var columns = new Array&lt;Int&gt;();
        for (x in 0...MAP_W) { // generate walls
            var y = 0;
            if (x == 0 || x == MAP_W - 1) { y = CANYON_Y; } // sides blocked
            else { // procedural wall pattern
                y = Math.round(Math.sin((x / MAP_W) * 3.14159) * // take half a sine
                    (MAP_H - CANYON_Y)); // scaling
                y += CANYON_Y; // offset
                y += Std.int(Math.random() * 6 - 3); // noise
                // clamp:
                if (y &lt; CANYON_Y) y = CANYON_Y;
                if (y &gt;= MAP_H) y = MAP_H - 1;
            }
            columns.push(y);
        }
        for (x in 0...MAP_W - 2) { // smooth columns to prevent narrow gaps
            if (columns[x] &lt; columns[x + 1] &amp;&amp; columns[x + 2] &lt; columns[x + 1])
            {
                columns[x + 1] = columns[x];
            }
        }
        for (x in 0...MAP_W) { // set the columns
            var wall_y = columns[x];
            for (y in 0...MAP_H) {
                var idx = map.i(x, y);
                if (y &gt;= CANYON_Y) { // start drawing canyon here
                    if (y &gt;= wall_y) {
                        map.d[idx] = MTWall;
                    } else {
                        map.d[idx] = // score based on depth
                        MTRock(Std.int((y - CANYON_Y + 1) * 5 / 
                            (MAP_H - CANYON_Y)));
                    }
                } else {
                    map.d[idx] = MTNone;
                }
            }
        }
        for (y in 0...map.h) { // smooth canyon
            for (x in 0...map.w) {
                var idx = map.i(x, y);
                if (map.d[idx] == MTWall &amp;&amp; 
                    y &gt; 0 &amp;&amp; 
                    map.d[idx - MAP_W] != MTWall &amp;&amp;
                    map.d[idx - MAP_W] != MTWallTL &amp;&amp;
                    map.d[idx - MAP_W] != MTWallTR
                    ) {
                    if (x &gt; 0 &amp;&amp; map.d[idx - 1] != MTWall &amp;&amp;
                        map.d[idx - 1] != MTWallTL &amp;&amp;
                        map.d[idx - 1] != MTWallTR)
                        map.d[idx] = MTWallTL;
                    else if (x &lt; map.w - 1 &amp;&amp; 
                        map.d[idx + 1] != MTWall &amp;&amp;
                        map.d[idx + 1] != MTWallTL &amp;&amp;
                        map.d[idx + 1] != MTWallTR)
                        map.d[idx] = MTWallTR;
                }
            }
        }       
    }
    
    public function onDown(k : Key, s : String) {
        fire = true;
    }
    public function onUp(k : Key, s : String) {
        fire = false;
    }
    public function onDownMouse(button : Int, x : Int, y : Int) {
        fire = true;
    }
    public function onUpMouse(button : Int, x : Int, y : Int) {
        fire = false;
    }
    
    public function render(framebuffer: Framebuffer): Void {
        if (!load_finished) return;
        // color settings
        var col_bg = Color.Black;
        var col_plane = Color.White;
        var col_bomb = Color.Red;
        var col_wall = Color.Blue;
        var col_rock = [Color.Orange, Color.Pink, Color.Purple, 
            Color.Red, Color.Cyan];
        var col_explosion = Color.White;
        var transform = FastMatrix3.scale(
            System.pixelWidth / WIDTH, 
            System.pixelHeight / HEIGHT);
        { // graphics2 calls
            var g = framebuffer.g2;
            g.begin();
            g.pushTransformation(transform);
            { // render bg
                g.clear(col_bg);
            }
            { // render canyon
                var x = 0.;
                var y = 0.;
                for (t0 in map.d) {
                    switch(t0) {
                        case MTNone:
                        case MTWall:
                            g.color = col_wall;
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;block&quot;);
                        case MTWallTL:
                            g.color = col_wall;
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;blocktl&quot;);
                        case MTWallTR:
                            g.color = col_wall;
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;blocktr&quot;);
                        case MTRock(v):
                            g.color = col_rock[v%5];
                            sprite.draw(g, 
                                x * TILE_W, y * TILE_H, 
                                0, &quot;boulder&quot;);                          
                    }
                    x += 1;
                    if (x &gt;= MAP_W) { x = 0; y += 1; }
                }
            }
            for (p in player) {
                { // render plane
                    g.color = col_plane;
                    var mirror = 1;
                    var plane = p.plane;
                    if (plane.vx &lt; 0) mirror = -1;
                    var spr = &quot;plane&quot;;
                    if (isBlimp(plane))
                        spr = &quot;blimp&quot;;
                    sprite.drawCenterScaled(g, plane.x, plane.y,
                        plane.w, plane.h, 
                        mirror, 1, 0, spr);
                }
                if (p.bomb.alive) { // render bomb
                    var bomb = p.bomb;
                    g.color = col_bomb;
                    sprite.drawCenter(g, bomb.x, bomb.y, bomb.w, bomb.h, 
                        0, &quot;bomb&quot;);
                }
            }
            for (p in particle) { // render particles
                if (p.time &gt; 0) {
                    g.color = col_explosion;
                    sprite.draw(g, p.x, p.y, p.sprite_image, p.sprite_name);
                }
            }
            { // render some text
                if (game_over) {
                    string(
                        g, 'SCORE ${player[0].score}     HIGH ${high_score}',
                        8, 8, 1
                    );
                    var gotxt = 'Game Over'.toUpperCase();
                    centerString(
                        g, 
                        gotxt,
                        WIDTH / 2,
                        HEIGHT / 2,
                        1
                    );
                } else {
                    string(
                        g,
                        'LIVES ${player[0].lives}     SCORE ${player[0].score}' +
                        '     HIGH ${high_score}',  
                        8, 8, 1
                    );
                }
            }
            g.popTransformation();
            g.end();
        }
    }
    
    public function outOfBounds(plane : Plane) {
        return (plane.x &gt; WIDTH + plane.w || plane.x &lt; -plane.w * 2);
    }
    public function respawnPlane(plane : Plane) {
        if (Math.random() &gt; 0.5) {
            plane.x = -plane.w + 1;
            plane.vx = 1;
        } else {
            plane.x = WIDTH + 1;
            plane.vx = -1;
        }
        plane.y = (Math.random() * (PLANE_MAXY - PLANE_MINY)) 
            + PLANE_MINY;
        plane.vx *= Math.min(0.5 + (plane.passes+1) * 0.15, 1.5);
        if (channel_engine_blimp != null) channel_engine_blimp.stop();
        if (channel_engine_plane != null) channel_engine_plane.stop();
        if (isBlimp(plane)) {
            channel_engine_blimp = Audio.play(Assets.sounds.engine_blimp, true);
            channel_engine_blimp.volume = 0.0;
        } else {
            channel_engine_plane = Audio.play(Assets.sounds.engine_plane, true);            
            channel_engine_plane.volume = 0.0;
        }
    }
    
    public function update(): Void {
        if (!load_finished) return;
        for (p in player) {
            var bomb = p.bomb;
            var plane = p.plane;
            { // if we tapped the button spawn the bomb, if possible
                if (!game_over &amp;&amp; fire &amp;&amp; !bomb.alive &amp;&amp; p.lives &gt; 0)  {
                    bomb.alive = true;
                    bomb.x = plane.x + plane.w / 2 - bomb.w / 2;
                    bomb.y = plane.y + plane.h;
                    bomb.vx = plane.vx;
                    bomb.vy = 0.;
                    bomb.hit = false;
                    bomb.hit_time = BOMB_HIT_TIMER;
                    p.plane.dropped = true;
                    channel_drop = playRandom(sound_bomb);
                } else if (fire &amp;&amp; game_over) {
                    startGame();
                }
            }
            { // advance plane movement
                plane.x += plane.vx;
                plane.y += plane.vy;
                { // adjust engine noise volume
                    var ch : AudioChannel;
                    if (Math.abs(plane.vx) &lt; IS_BLIMP_UNTIL_VX)
                        ch = channel_engine_blimp;
                    else
                        ch = channel_engine_plane;
                    if (ch != null)
                        ch.volume = Math.sin((plane.x / WIDTH) * Math.PI * 0.9 + 0.1); 
                }
                // move plane into new passing position; end turn
                var turn_over = false;
                if (outOfBounds(plane) &amp;&amp; !bomb.alive)
                {
                    plane.passes += 1;
                    respawnPlane(plane);
                    turn_over = true;
                }
                if (turn_over &amp;&amp; !game_over) {
                    // test for whether turn was successful
                    if (!p.plane.dropped) {
                        p.lives -= 1;
                        Audio.play(Assets.sounds.miss);
                        channel_drop.stop();
                    } else if (!p.bomb.alive) {
                        //Audio.play(Assets.sounds.hit);
                        channel_drop.stop();
                    }
                    p.plane.dropped = false;
                    // test for new level
                    var newlevel = true;
                    for (t in map.d) {
                        if (t.getIndex() == MTRock(0).getIndex()) {
                            newlevel = false;
                        }
                    }
                    if (newlevel) {
                        startLevel();
                    }
                    if (p.lives &lt; 1) {
                        game_over = true;
                        if (p.score &gt; high_score)
                            high_score = p.score;
                    }
                }
            }
            { // advance bomb movement
                if (bomb.alive) {
                    bomb.vy += BOMB_GRAVITY; // gravity
                    bomb.x += bomb.vx;
                    bomb.y += bomb.vy;
                    var top = bomb.y;
                    var left = bomb.x;
                    var right = bomb.x + bomb.w;
                    var bottom = bomb.y + bomb.h;
                    var i0 = map.p2i(left, top);
                    var i1 = map.p2i(right, top);
                    var i2 = map.p2i(left, bottom);
                    var i3 = map.p2i(right, bottom);
                    var damage = 0;
                    damage = Std.int(Math.max(damage, bombCollision(i0, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i1, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i2, p)));
                    damage = Std.int(Math.max(damage, bombCollision(i3, p)));
                    if (damage &gt; 0 &amp;&amp; bomb.hit)
                    {
                        if (channel_break == null || channel_break.position &gt; 0)
                            channel_break = playRandom(sound_explode);
                    }
                    bomb.hit_time -= damage;
                    if (bomb.hit_time &lt; 1) bomb.alive = false;
                    if (bomb.y &gt; HEIGHT)
                        bomb.alive = false;
                    if (!bomb.alive &amp;&amp; !bomb.hit)
                    {
                        p.lives -= 1;
                        Audio.play(Assets.sounds.miss);
                    }
                }
            }
        }
        if (rockfall_time &lt; 1) { // advance the rock fall
            rockfall_time = ROCKFALL_TIMER;
            for (y in 1...MAP_H) {
                var iy0 = (MAP_H - 1) - y; // rock to fall
                var iy1 = iy0 + 1; // tile underneath
                for (x in 0...MAP_W) {
                    var idx0 = map.i(x, iy0);
                    var idx1 = map.i(x, iy1);
                    if (map.d[idx0].getIndex() == Type.enumIndex(MTRock(0))
                        &amp;&amp; map.d[idx1] == MTNone)
                    {
                        map.d[idx1] = map.d[idx0];
                        map.d[idx0] = MTNone;
                    }
                }
            }
        } else {
            rockfall_time--;
        }
        for (p in particle) { // particle simulation
            if (p.time &gt; 0) {
                switch(p.program) { // run particle program
                    case Explosion:
                        p.sprite_image = 0;
                        if (p.time &gt; EXPLODE_1) {
                            p.sprite_name = &quot;explosion1&quot;;
                        }
                        else if (p.time &gt; EXPLODE_2) {
                            p.sprite_name = &quot;explosion2&quot;;
                        }
                        else if (p.time &gt; EXPLODE_3) {
                            p.sprite_name = &quot;explosion3&quot;;
                        }
                        else {
                            p.sprite_name = &quot;explosion4&quot;;
                        }
                        p.y -= 0.2;
                }
                p.time -= 1;
            }
        }
    }
    
    public function bombCollision(idx : Int, p : Player) : Int {
        if (idx &lt; 0 || idx &gt; map.d.length) return 0;
        else switch(map.d[idx]) {
            case MTNone: return 0;
            case MTWall, MTWallTL, MTWallTR: return BOMB_HIT_TIMER;
            case MTRock(v): map.d[idx] = MTNone; 
                p.score += v;
                p.bomb.hit = true;
                spawnParticle(
                    map.x2p(map.x(idx)), 
                    map.y2p(map.y(idx)), Explosion);
                return 1;
        }
    }
    
    public function spawnParticle(x : Float, y : Float, program : ParticleProgram) {
        for (pi in 0...particle.length) {
            var p = particle[pi];
            if (p.time &lt;= 0) {
                p.program = program;
                p.x = x;
                p.y = y;
                switch(program) {
                    case Explosion:
                        p.time = Std.int(EXPLODE_0 + Math.random() * 6);
                }
                return pi;
            }
        }
        return -1;
    }
    
    public function isBlimp(p : Plane) {
        return (Math.abs(p.vx) &lt; IS_BLIMP_UNTIL_VX);
    }
    
    public function string(g, s, x : Float, y : Float, spacing) {
        sprite.string(
            g, 
            Std.int(x + 1),
            Std.int(y + 1),
            s,
            &quot;alphabet2&quot;, spacing
        );
        sprite.string(
            g, 
            Std.int(x),
            Std.int(y),
            s,
            &quot;alphabet1&quot;, spacing
        );
    }
    public function centerString(g, s, x : Float, y : Float, spacing) {
        sprite.string(
            g, 
            Std.int(x - sprite.stringWidth(s, &quot;alphabet2&quot;, spacing) / 2 + 1),
            Std.int(y - sprite.stringHeight(s, &quot;alphabet2&quot;) / 2 + 1),
            s,
            &quot;alphabet2&quot;, spacing
        );
        sprite.string(
            g, 
            Std.int(x - sprite.stringWidth(s, &quot;alphabet1&quot;, spacing) / 2),
            Std.int(y - sprite.stringHeight(s, &quot;alphabet1&quot;) / 2),
            s,
            &quot;alphabet1&quot;, spacing
        );
    }
    
    public function playRandom(ar : Array&lt;String&gt;) {
        return Audio.play(
            Reflect.field(Assets.sounds, (ar[Std.int(Math.random() * ar.length)])));
    }
    
}
</programlisting>
</sect1>
</chapter>



<chapter id="last-thoughts">
<title>Last Thoughts</title>
<sect1>
  <para>
    This guide presents a working game, but that doesn't mean it's
    &quot;finished&quot;. There are bugs, features, and design changes to think about.
  </para>
  <para>
    There is a minor but slightly annoying bug: If you hold the button down after the
    plane flies offscreen, it will repeatedly drop useless bombs until all lives are lost.
  </para>
  <para>
    Sometimes, the bomb hits a single rock, but two different rock breaking sounds play.
  </para>
  <para>
    The game has no title screen, it simply says &quot;GAME OVER&quot;
    when the gameplay hasn't started. This is authentic to the original,
    but not up to modern standards - it could present GAME OVER
    temporarily, then go to a high scores screen, show instructions,
    present an attract-mode demo, etc.
  </para>
  <para>
    Multiplayer is part of the original Canyon Bomber game, but it's not
    included here. Fixing this will require some changes to the UI,
    graphics, and sound routines.
  </para>
  <para>
    The game is unforgivingly strict in a way that is typical of 1970's
    arcade games; a modern version might consider alternatives to
    &quot;lives&quot;, end the level before clearing every last rock, or
    change some aspects of the bomb drop and how it's lined up.
  </para>
  <para>
    The gameplay works on the small scale, but doesn't expand or unfold.
    It could use a longer-term focus like upgrading your plane,
    pre-designed puzzles with ingenious solutions, a second phase which
    uses the cleared canyon in a different way, different scenarios for
    bombing, etc.
  </para>
  <para>
    And, of course, the graphics and sound could always be done with
    more detail.
  </para>
</sect1>
</chapter>




<chapter id="troubleshooting">
<title>Troubleshooting</title>
<sect1 id="i-got-an-error-but-who-should-i-ask-about-it">
  <title>I got an error, but who should I ask about it?</title>
  <itemizedlist>
    <listitem>
      <para>
        If you encounter <emphasis>language or code generation
        errors</emphasis>, it is probably a Haxe issue.
      </para>
    </listitem>
    <listitem>
      <para>
        If you encounter <emphasis>API, asset import, or build
        problems</emphasis>, it is probably a Kha issue.
      </para>
      <para>
        At this time, the fastest way to get responses to Kha questions is through
        the IRC channel: 
        <blockquote>irc.ktxsoftware.com #kha</blockquote>
        There is also a channel log with old questions at 
        <ulink url="http://khaflixel.ratalaikagames.com/irc/">http://khaflixel.ratalaikagames.com/irc/</ulink>
      </para>
    </listitem>
  </itemizedlist>
</sect1>
<sect1 id="debugging-performance-issues">
  <title>Debugging Performance Issues</title>
  <para>
    If you are testing in the browser, make sure it's a clean
    environment. In Firefox 42.0, for example, old open tabs will share
    garbage collection pauses with your game.
  </para>
  <para>
    Make sure you are using appropriate timing mechanisms. Most
    simulation code runs best as a Scheduler TimeTask. You can divide up
    the simulation into multiple tasks running on different intervals if
    necessary; the framework will do its best to run your tasks in the
    correct order given the intervals and priorities you set. If the
    hotspot code is related to rendering, then it should probably be a
    FrameTask.
  </para>
</sect1>
<sect1 id="build-and-asset-problems">
  <title>Build and Asset Problems</title>
  <para>
    Make sure there aren't file locking issues. Disable any automatic
    sync programs, reopen the project if it's been regerated, close and
    reopen editors and command consoles, reboot if you're feeling
    particularly paranoid.
  </para>
  <para>
    Make sure you've tried to load your assets before using them - if
    you aren't using loadEverything(), make sure you've loaded the
    <emphasis>right</emphasis> assets.
  </para>
</sect1>
<sect1 id="html5-builds">
  <title>HTML5 Builds</title>
  <para>
    When targeting the Web, security and networking considerations come
    into play as part of loading your game. In many cases pointing
    your browser at the generated index.html will run the game.
  </para>
  <para>
    You can also force your Khabuild process to run a server with the
    --server parameter. It defaults to
    <ulink url="http://localhost:8080">http://localhost:8080</ulink>.
  </para>
</sect1>
</chapter>


<chapter id="contributing">
<title>Contributing to the Kha Guide</title>
<sect1 id="contributors-guide">
  <para>
    The goal of this guide is provide a narrative of game development,
    as a way of familiarizing readers with Kha and also with broader
    processes involved in game development.
  </para>
  <para>
    To do this, the guide provides complete code examples, allowing the
    reader to bring them into a &quot;real&quot; environment as soon as
    possible by copy-pasting example code. The API is introduced
    gradually and naturally, in the way it would appear in a real
    project.
  </para>
  <para>
    The guide opts, where reasonable, to be brave. It presents genuine
    challenges that put the framework to the test, rather than small
    synthetic examples.
  </para>
  <para>
    The guide's format is
    <ulink url="https://help.github.com/articles/github-flavored-markdown/">Github-flavored
    Markdown</ulink>. (Should the needs of the guide change, format
    conversion may be considered in the future.)
  </para>
  <para>
    External editors are recommended to ease the pain of syntax and
    organization. @Triplefox uses a mix of
    <ulink url="http://twinery.org/">Twine 2</ulink> (hypertext design)
    and <ulink url="http://www.mdcharm.com/">MdCharm</ulink> (body text
    formatting).
  </para>
</sect1>
<sect1 id="common-technical-writing-practices">
    <title>Common Technical Writing Practices</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Lead with the &quot;what&quot; and &quot;why&quot; of each
          item: What is this, and why do I need it?
        </para>
      </listitem>
      <listitem>
        <para>
          Follow up with the &quot;when&quot; and &quot;where&quot;: in
          which situation is it needed?
        </para>
      </listitem>
      <listitem>
        <para>
          Do not use &quot;should&quot;, &quot;may&quot;,
          &quot;can&quot;, or &quot;when&quot; to describe a task.
        </para>
      </listitem>
      <listitem>
        <para>
          Prefer &quot;shall&quot;, &quot;must&quot;, &quot;will&quot;
          or &quot;shall not&quot;, &quot;must not&quot;, &quot;will
          not&quot;.
        </para>
      </listitem>
      <listitem>
        <para>
          Break tasks into 7 steps, plus or minus two.
        </para>
      </listitem>
      <listitem>
        <para>
          If more steps are required, use subheadings and group the
          steps into logical categories.
        </para>
      </listitem>
    </itemizedlist>
</sect1>
<sect1 id="terms">
    <title>Terms</title>
    <para>
      &quot;haxelib&quot; vs &quot;standalone&quot; builds of Kha
      projects. The former use the version of Kha currently updated on
      Haxelib. The latter use Kha as a Git submodule.
    </para>
</sect1>
<sect1 id="style">
    <title>Style</title>
    <para>
      Quotes and asides are written using blockquote syntax:
    </para>
    <para>
      According to Plato,
    </para>
    <blockquote>
      <para>
        <emphasis>The beginning is the most important part of the
        work.</emphasis>
      </para>
    </blockquote>
    <para>
      Source should be kept inline with the document where possible,
      using the appropriate syntax highlighting hint:
    </para>
    <programlisting language="haxe">

class HelloWorld {
    public function new() {
        trace(&quot;hello world&quot;);
    }
}
</programlisting>
</sect1>
</chapter>

</book>
